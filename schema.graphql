# Function score mutations
type ASAdminFunctionScoreMutations {
  # Remove function score specification
  removeFunction(
    # Function score id to be removed
    id: String!
  ): Boolean

  # Upload function score specification
  uploadFunction(
    # Function score id, will be used as reference at query time.
    id: String!

    # Describes what this function score does.
    description: String

    # Function score file
    file: String!
  ): Boolean
}

# Function score admin entry point
type ASAdminFunctionScoreQueries {
  # List available function score functions
  functions(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int
  ): FunctionScoreConnection
}

# Generic object with admin mutation results
type ASAdminMutations {
  # Add site to the list of indexed sites
  addSite(
    # Site key
    siteKey: String!
  ): String

  # Clear the database connection to use with Augmented Search (indexation and querying)
  clearDbConnection: String

  # Function score mutations
  functionScore: ASAdminFunctionScoreMutations

  # Remove site from the list of indexed sites
  removeSite(
    # Site key
    siteKey: String!
  ): String

  # Set the database connection to use with Augmented Search (indexation and querying)
  setDbConnection(
    # DB connection id
    connectionId: String!
  ): String

  # Given a list of sites, trigger bulk indexing. If no sites are provided, triggers a full reindex.
  startIndex(
    # List of siteKeys to index
    siteKeys: [String]

    # Can be LIVE or EDIT or null for both
    workspace: Workspace

    # Force start indexation for when job has already been started
    force: Boolean = false
  ): indexMutationResult
}

# List of indexed sites entry point
type ASAdminQueries {
  # Current database connection ID used by Augmented Search
  currentConnection: String

  # Get current shard configuration
  currentShardConfiguration: GqlShardConfiguration

  # List of available database connections
  dbConnections: [GqlAvailableConnection]

  # Function score queries
  functionScore: ASAdminFunctionScoreQueries

  # Get index sizes
  indexSizes: [GqlIndexSize]

  # List sites configured for Augmented Search
  listSites: siteList

  # Get optimal shard configurations
  optimalShardConfigurations(
    # Maximum average shard size allowed, in Gb
    maxShardSizeInGb: Float

    # Minimum amount of heap memory for each shard, in Mb
    minHeapPerShardInMb: Float
  ): [GqlShardConfiguration]
}

# Admin mutations
type AdminMutation {
  # Get Jahia admin mutation
  jahia: JahiaAdminMutation!

  # Augmented Search administrative mutations
  search: ASAdminMutations

  # Personal API tokens mutations
  personalApiTokens: PersonalApiTokensMutation
}

# Admin queries root
type AdminQuery {
  # Current datetime
  datetime: String

  # Get Jahia admin query
  jahia: JahiaAdminQuery!

  # Version of the running Jahia instance
  version: String! @deprecated(reason: "Deprecated")

  # Get user group endpoint
  userGroup: UserGroupQuery

  # Get user administration endpoint
  userAdmin: UserAdminQuery

  # Augmented Search administrative queries
  search: ASAdminQueries

  # Personal API tokens queries
  personalApiTokens: PersonalApiTokensQuery
}

# Asset type for files
type Asset {
  # Asset metadata
  metadata: Metadata

  # Mime type of the asset
  type: String

  # Asset size
  size: Long
}

# Category type
type Category {
  # Asset metadata
  metadata: Metadata

  # Description
  description: String

  # Title
  title: String
}

# Mutation for configuration value object
type ConfigurationItemValuesMutation {
  # Modify a list of items
  mutateList(
    # property name part
    name: String
  ): ConfigurationItemsListMutation

  # Modify a structured object
  mutateObject(
    # property name part
    name: String
  ): ConfigurationItemValuesMutation

  # Remove the specified property and all sub/list properties
  remove(
    # property name part
    name: String
  ): Boolean

  # Set a property value
  value(
    # property name part
    name: String
    value: String
  ): String
}

# Query for configuration value object
type ConfigurationItemValuesQuery {
  # Get keys
  keys: [String]

  # Get a list of items
  list(
    # property name part
    name: String
  ): ConfigurationItemsListQuery

  # Get a sub structured object value
  object(
    # property name part
    name: String
  ): ConfigurationItemValuesQuery

  # Get a property value
  value(
    # property name part
    name: String
  ): String

  # Get property values
  values: [GqlConfigurationProperty]
}

# Mutation for configuration list of values
type ConfigurationItemsListMutation {
  # Adds a new sub list to the list
  addList: ConfigurationItemsListMutation

  # Adds a new structured object to the list
  addObject: ConfigurationItemValuesMutation

  # Adds a property value to the list
  addValue(value: String): String
}

# Query for configuration list of values
type ConfigurationItemsListQuery {
  # Get sub lists of items
  lists: [ConfigurationItemsListQuery]

  # Get sub structured object values
  objects: [ConfigurationItemValuesQuery]

  # Adds a new structured object to the list
  size: Int

  # Get property values
  values: [String]
}

# Simple node count aggregation
type CountAggregation {
  # Count all values
  values(
    # The name of the JCR property
    name: String!

    # The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
    language: String
  ): Int
}

# GraphQL representation of a Jahia current user
type Current_32_user {
  # Full display name
  displayName: String

  # Email of the user
  email: String

  # First name of the user
  firstname: String

  # Preferred language by the user
  language: String

  # Last name of the user
  lastname: String

  # Displays if user is locked
  locked: Boolean

  # User name
  name: String! @deprecated(reason: "Deprecated")

  # Get the corresponding JCR node
  node: JCRNode

  # User organization
  organization: String

  # User property
  property(
    # The name of the property
    name: String!
  ): String

  # Site where the user is defined
  site: JCRSite

  # Username of the user
  username: String!

  # Is this principal member of the specified group
  memberOf(
    # Target group
    group: String

    # Site where the group is defined
    site: String
  ): Boolean
}

# Date type
scalar Date

type DateRangeValue {
  count: Int
  range: Range
}

type EditorForm {
  # Retrieve a description text for the form, might contain explanations on how to use the form
  description: String

  # Retrieve the displayable name of the form (in a specific language)
  displayName: String

  # Retrieve the name (aka identifier) of the form
  name: String

  # Retrieve the sections that make up the form
  sections: [EditorFormSection]

  # Returns the preview status of the form. If true, the form can display a preview.
  hasPreview: Boolean
}

type EditorFormField {
  # This value contains the current existing values for the field.
  currentValues: [EditorFormFieldValue]

  # The declaring node type for the field
  declaringNodeType: String

  # This value contains the default values for the field.
  defaultValues: [EditorFormFieldValue]

  # The description of the field
  description: String

  # The displayable name of the field
  displayName: String

  # The error message of the field
  errorMessage: String

  # This value is true if the field allows for internationalized values
  i18n: Boolean

  # This value is true if the field is mandatory
  mandatory: Boolean

  # This value is true if the field value is multi-valued.
  multiple: Boolean

  # The name of the field
  name: String

  # This value is true if the field is readonly. This could be due to locks or permissions
  readOnly: Boolean

  # The required type for the field
  requiredType: JCRPropertyType

  # Options for the selector type. For JCR definitions, this will usually include choicelist initializer name and properties.
  selectorOptions: [EditorFormProperty]

  # The selector type for the field. In the case of fields generated from node types, this is actually the SelectorType.
  selectorType: String

  # This array contains the list of possible values to choose from
  valueConstraints: [EditorFormFieldValueConstraint]
}

type EditorFormFieldSet {
  # Only used in the case of a dynamic field set. Set to true if it is activated
  activated: Boolean

  # Get the internationalized description of the field set
  description: String

  # Get the internationalized displayable name of the field set
  displayName: String

  # Defines if the field has to be displayed or not
  displayed: Boolean

  # True if this is dynamic field set (meaningin it can be activated or not)
  dynamic: Boolean

  # Get the fields contained in the target
  fields: [EditorFormField]

  # Get the name of the field set
  name: String

  # This value is true if the fieldset is readonly. This could be due to locks or permissions
  readOnly: Boolean
}

type EditorFormFieldValue {
  # This value's string representation
  string: String

  # The type of this value
  type: String
}

type EditorFormFieldValueConstraint {
  # The value as it is intended to be displayed in UIs
  displayValue: String

  # The properties for the value
  properties: [EditorFormProperty]

  # The actual value to be used in storage
  value: EditorFormFieldValue
}

type EditorFormProperty {
  # Property name
  name: String

  # Property value
  value: String
}

type EditorFormSection {
  # Is the section expanded
  expanded: Boolean

  # Returns the description of the section
  description: String

  # Retrieve the displayable name of the section
  displayName: String

  # Returns the field sets contained in this section
  fieldSets: [EditorFormFieldSet]

  # Retrieve the name (aka identifier) of the section
  name: String

  # Check if this section should be hide
  hide: Boolean
}

enum FieldEvaluation {
  # The field value is equal to given one
  EQUAL

  # The field value is different from given one
  DIFFERENT

  # The field value is empty - either null value, or no items for a list
  EMPTY

  # The field value is not empty - if a list, must contain at least one item
  NOT_EMPTY

  # The property value contains given String
  CONTAINS

  # The property value contains given String ignoring the case
  CONTAINS_IGNORE_CASE

  # The property value is among given Strings
  AMONG
}

# Functions score representation
type FunctionScore {
  # Function score description
  description: String

  # Function score id
  id: String

  # JSON string
  json: String
}

# A connection to a list of items.
type FunctionScoreConnection {
  # a list of nodes
  nodes: [FunctionScore]

  # a list of edges
  edges: [FunctionScoreEdge]

  # details about this specific page
  pageInfo: PageInfo!
}

# An edge in a connection
type FunctionScoreEdge {
  # The item at the end of the edge
  node: FunctionScore

  # cursor marks a unique position or index into the connection
  cursor: String!

  # index in the connection
  index: Int
}

# GraphQL representation of a generic JCR node
type GenericJCRNode implements JCRNode {
  # Get the last modified date of this node and its descendants. The recursion in descendants can be controlled by recursionTypesFilter. If no filter is passed, recursion will stop by default on sub pages.
  aggregatedLastModifiedDate(
    # The language
    language: String

    # Stop recursion on graphql field values
    recursionTypesFilter: InputNodeTypesInput
  ): String

  # GraphQL representations of the ancestor nodes of the JCR node, top down direction
  ancestors(
    # The path of the topmost ancestor node to include in the result; null or empty string to include all the ancestor nodes
    upToPath: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNode]!

  # GraphQL representations of the child nodes, according to parameters passed
  children(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter of child nodes by their names; null to avoid such filtering
    names: [String]

    # Language to use to get children
    validInLanguage: String

    # Filter of child nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Filter of child nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput

    # Include the current node itself in results
    includesSelf: Boolean = false
  ): JCRNodeConnection

  # GraphQL representation of a descendant node, based on its relative path
  descendant(
    # Name or relative path of the sub node
    relPath: String!
  ): JCRNode

  # GraphQL representations of the descendant nodes, according to parameters passed
  descendants(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter of descendant nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Language to use to get children
    validInLanguage: String

    # Filter of descendant nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput

    # Filter out and stop recursion on nodes by their types; null to avoid such filtering
    recursionTypesFilter: InputNodeTypesInput

    # Filter out and stop recursion on nodes by their property values; null to avoid such filtering
    recursionPropertiesFilter: InputNodePropertiesInput

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput
  ): JCRNodeConnection

  # The displayable name of the JCR node
  displayName(
    # Language
    language: String
  ): String

  # Check if the given locales need translation, by comparing last modifications dates with already existing translations
  languagesToTranslate(
    # The translated languages
    languagesTranslated: [String]

    # The languages to check
    languagesToCheck: [String]
  ): [String]

  # The name of the JCR node this object represents
  name: String!

  # GraphQL representation of this node in certain workspace
  nodeInWorkspace(
    # The target workspace
    workspace: Workspace!
  ): JCRNode

  # Get information on the operations that can be done on this node
  operationsSupport: GqlOperationsSupport

  # GraphQL representation of the parent JCR node
  parent: JCRNode

  # The path of the JCR node this object represents
  path: String!

  # GraphQL representations of the properties in the requested language
  properties(
    # The names of the JCR properties; null to obtain all properties
    names: [String]

    # The language to obtain the properties in; must be a valid language code in case any internationalized properties are requested, does not matter for non-internationalized ones
    language: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRProperty]!

  # The GraphQL representation of the property in the requested language; null if the property does not exist
  property(
    # The name of the JCR property
    name: String!

    # The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
    language: String
  ): JCRProperty

  # GraphQL representations of the reference properties that target the current JCR Node
  references(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): JCRPropertyConnection!

  # The UUID of the JCR node this object represents
  uuid: String!

  # Get the workspace of the query
  workspace: Workspace!

  # Check if the current user has a specific permission
  hasPermission(
    # The name of the permission
    permissionName: String!
  ): Boolean

  # Read default Work in progress information. Set by "wip.checkbox.checked" system proprety
  defaultWipInfo: wipInfo

  # Read work in progress information for a given node
  wipInfo: wipInfo

  # Get vanity URLs from the current node filtered by the parameters
  vanityUrls(
    # Languages
    languages: [String]

    # Filter results based on graphql field values
    fieldFilter: InputFieldFiltersInput
  ): [VanityUrl]

  # Retrieve lock info of the current node
  lockInfo: LockInfo

  # Aggregated publication info about the JCR node
  aggregatedPublicationInfo(
    # Publication language
    language: String!

    # Whether to take sub-nodes into account when calculating the aggregated publication status
    subNodes: Boolean = false

    # Whether to take references into account when calculating the aggregated publication status
    references: Boolean = false
  ): GqlPublicationInfo!

  # Give access to the experience fields for the current node
  asExperience: GqlExperience
  jExperience(
    # Unomi profile id
    profileId: String

    # Unomi session id
    sessionId: String
  ): PersonalizedResult

  # Render URL in ajax mode
  ajaxRenderUrl: String

  # Returns the first parent of the current node that can be displayed in full page. If no matching node is found, null is returned.
  displayableNode: JCRNode

  # Gets the fully rendered content for this node
  renderedContent(
    # Name of the view
    view: String

    # Template type
    templateType: String

    # Rendering context configuration
    contextConfiguration: String

    # Language
    language: String

    # Main resource path
    mainResourcePath: String

    # Is edit mode
    isEditMode: Boolean

    # Additional request attributes
    requestAttributes: [InputRenderRequestAttributeInput]
  ): RenderedNode

  # Check if the node as a renderable template associated with it (not a view a template).
  isDisplayableNode: Boolean

  # GraphQL representation of the site the JCR node belongs to, or the system site in case the node does not belong to any site
  site: JCRSite

  # Returns the next available name for a node, appending if needed numbers.
  findAvailableNodeName(nodeType: String, language: String): String

  # Returns edit lock status of the current node object
  lockedAndCannotBeEdited: Boolean

  # Returns a list of types allowed under the provided node
  allowedChildNodeTypes(
    # Whether all sub-types of allowed child node types should be included
    includeSubTypes: Boolean = true

    # Filter by GraphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeType]

  # Returns the node definition that applies to this node.
  definition: JCRNodeDefinition

  # Returns an array of <code>NodeType</code> objects representing the mixin node types in effect for this node.
  mixinTypes(
    # Filter by GraphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeType]!

  # Get the primary node type of this node
  primaryNodeType: JCRNodeType!

  # Reports if the current node matches the nodetype(s) passed in parameter
  isNodeType(
    # Node type name
    type: InputNodeTypesInput!
  ): Boolean!
}

# Elasticsearch connection model
type GqlAvailableConnection {
  # Id of the connection
  connectionId: String

  # List of plugins if any
  plugins: [GqlPlugin]
}

type GqlBackgroundJob {
  # The amount of time the job ran for (in milliseconds). The returned value will be -1 until the job has actually completed
  duration: Long

  # The job group name
  group: String

  # The job (Boolean) property that correspond to the given name. The returned value will be null in case the job doesn't have the property
  jobBooleanProperty(name: String): Boolean

  # The job (Int) property that correspond to the given name. The returned value will be null in case the job doesn't have the property
  jobIntegerProperty(name: String): Int

  # The job (Long) property that correspond to the given name. The returned value will be null in case the job doesn't have the property
  jobLongProperty(name: String): Long

  # The job state is different from the status, it reflect the last action done on the job instance (Started, Vetoed, Finished)
  jobState: GqlBackgroundJobState

  # The job status
  jobStatus: GqlBackgroundJobStatus

  # The job (String) property that correspond to the given name. The returned value will be null in case the job doesn't have the property
  jobStringProperty(name: String): String

  # The job name
  name: String

  # The site key. The returned value will be null in case the job doesn't have associated site key
  siteKey: String

  # The user key. The returned value will be null in case the job doesn't have associated user key
  userKey: String
}

enum GqlBackgroundJobState {
  # STARTED
  STARTED

  # VETOED
  VETOED

  # FINISHED
  FINISHED
}

enum GqlBackgroundJobStatus {
  # ADDED
  ADDED

  # SCHEDULED
  SCHEDULED

  # EXECUTING
  EXECUTING

  # SUCCESSFUL
  SUCCESSFUL

  # FAILED
  FAILED

  # CANCELED
  CANCELED
}

# Mutation for OSGi configuration
type GqlConfigurationMutation {
  # Modify a list of items
  mutateList(
    # property name part
    name: String
  ): ConfigurationItemsListMutation

  # Modify a structured object
  mutateObject(
    # property name part
    name: String
  ): ConfigurationItemValuesMutation

  # Remove the specified property and all sub/list properties
  remove(
    # property name part
    name: String
  ): Boolean

  # Set a property value
  value(
    # property name part
    name: String
    value: String
  ): String
}

# OSGi configuration property
type GqlConfigurationProperty {
  # The property key
  key: String

  # The property value
  value: String
}

# Query for OSGi configuration
type GqlConfigurationQuery {
  # Get all properties of the configuration, as they are stored in OSGi
  flatKeys: [String]

  # Get all properties of the configuration, as they are stored in OSGi
  flatProperties: [GqlConfigurationProperty]

  # Get keys
  keys: [String]

  # Get a list of items
  list(
    # property name part
    name: String
  ): ConfigurationItemsListQuery

  # Get a sub structured object value
  object(
    # property name part
    name: String
  ): ConfigurationItemValuesQuery

  # Get a property value
  value(
    # property name part
    name: String
  ): String

  # Get property values
  values: [GqlConfigurationProperty]
}

type GqlDashboard {
  # Retrieves the list of modules currently available on the platform
  modules: [GqlModule]

  # Whether the tools are accessible on the installation
  toolsAccess: Boolean
}

type GqlDistributedSessionsMutation {
  # Delete a session
  removeSession(
    # Session id
    id: String!
  ): Boolean
}

type GqlDistributedSessionsQuery {
  localSessions(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # sort by GraphQL field values
    fieldSorter: InputFieldSorterInput

    # Group fields by criteria
    fieldGrouping: InputFieldGroupingInput
  ): GqlSessionConnection
  sessions(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # sort by GraphQL field values
    fieldSorter: InputFieldSorterInput

    # Group fields by criteria
    fieldGrouping: InputFieldGroupingInput
  ): GqlSessionConnection
  sessionsCount: Int
}

type GqlEditorFormMutations {
  # Publish the edited node with the associated technical sub nodes (visibility conditions, vanity urls, ACLs)
  publishForm(
    # UUID or path of the edited node.
    uuidOrPath: String!

    # A string representation of a locale, in IETF BCP 47 language tag format, ie en_US, en, fr, fr_CH, ...
    locale: String!
  ): Boolean

  # Unlock the given node for edition, if the node is locked.
  unlockEditor(
    # An ID generated client side used to identify the lock
    editorID: String!
  ): Boolean
}

type GqlEditorForms {
  # Retrieve the custom configuration path for CKEditor
  ckeditorConfigPath(
    # node path
    nodePath: String
  ): String

  # Retrieve the toolbar type for CKEditor
  ckeditorToolbar(
    # node path
    nodePath: String
  ): String

  # Get a list of allowed child nodeTypes for a given nodeType and path. (Note that it returns nothing for type [jnt:page]. [jnt:contentFolder] is filterered by [jmix:editorialContent])
  contentTypesAsTree(
    # List of types we want to retrieve, null for all
    nodeTypes: [String]

    # the child node name, used to check the type allowed for this named child node, do not specify if you want to check for unnamed children
    childNodeName: String

    # List of types we want to exclude, null for all
    excludedNodeTypes: [String]

    # if true, retrieves all the sub types of the given node types, if false, returns the type only. Default value is true
    includeSubTypes: Boolean = true

    # if true, check the contribute property of the node. Default value is true
    useContribute: Boolean = true

    # thPath of an existing node under with the new content will be created.
    nodePath: String!

    # A string representation of a locale, in IETF BCP 47 language tag format, ie en_US, en, fr, fr_CH, ...
    uiLocale: String!
  ): [NodeTypeTreeEntry]

  # Get a editor form to create a new content from its nodetype and parent
  createForm(
    # The primary node type name identifying the form we want to retrieve
    primaryNodeType: String!

    # A string representation of a locale, in IETF BCP 47 language tag format, ie en_US, en, fr, fr_CH, ...
    uiLocale: String!

    # A string representation of a locale, in IETF BCP 47 language tag format, ie en_US, en, fr, fr_CH, ...
    locale: String!

    # uuid or path of an existing node under with the new content will be created.
    uuidOrPath: String!
  ): EditorForm

  # Get a editor form from a locale and an existing node
  editForm(
    # A string representation of a locale, in IETF BCP 47 language tag format, ie en_US, en, fr, fr_CH, ...
    uiLocale: String!

    # A string representation of a locale, in IETF BCP 47 language tag format, ie en_US, en, fr, fr_CH, ...
    locale: String!

    # UUID or path of an existing node under with the new content will be created.
    uuidOrPath: String!
  ): EditorForm

  # Get field constraints
  fieldConstraints(
    # UUID or path of the node (optional in case you are creating it, and it doesnt exist yet)
    nodeUuidOrPath: String

    # UUID or path of the parent node
    parentNodeUuidOrPath: String!

    # A string representation of the primary node type of the node
    primaryNodeType: String!

    # A string representation of the field node type (the node type that contains the field, can be the node type of the node, a mixin or a super type)
    fieldNodeType: String!

    # A string representation of field name
    fieldName: String!

    # Object contains additional information of the node
    context: [InputContextEntryInput]

    # A string representation of a locale, in IETF BCP 47 language tag format, ie en_US, en, fr, fr_CH, ...
    uiLocale: String!

    # A string representation of a locale, in IETF BCP 47 language tag format, ie en_US, en, fr, fr_CH, ...
    locale: String!
  ): [EditorFormFieldValueConstraint]

  # Retrieve the number of sub contents under the node for given types
  subContentsCount(
    # node path
    nodePath: String

    # List of node types to check for
    includeTypes: [String]

    # Limit of sub contents count
    limit: Int
  ): Int
}

type GqlExperience {
  # get Experience type
  experienceType: GqlExperienceType

  # Check if this experience is active
  active: Boolean
}

type GqlExperienceType {
  # Get the primary node type of the experience node
  primaryNodeType: JCRNodeType

  # Get the primary node type name of the experience node
  primaryNodeTypeName: String

  # Get the experience target
  target: Target

  # Get the experience main type
  type: Type
}

# Server healthCheck
type GqlHealthCheck {
  probes: [GqlProbe]

  # Highest reported status across all probes
  status: GqlProbeStatus
}

type GqlHzPartition {
  id: Int
  owner: String
}

# Index size
type GqlIndexSize {
  # Index name
  name: String

  # Index size in bytes
  size: Long
}

type GqlJcrImageTransformMutation {
  # Crop an image under the current node
  cropImage(
    # new height
    height: Int!

    # new width
    width: Int!

    # top
    top: Int!

    # left
    left: Int!
  ): Boolean

  # The transformed node
  node: JCRNode

  # Resize an image under the current node
  resizeImage(
    # new height
    height: Int!

    # new width
    width: Int!
  ): Boolean

  # Rotate an image under the current node
  rotateImage(
    # angle in degrees
    angle: Float!
  ): Boolean
}

# Details on a lock
type GqlLockDetail {
  # Language
  language: String

  # Lock owner
  owner: String

  # Lock type
  type: String
}

type GqlMetricsFacetResult {
  # The field that was used to run the aggregation
  field: String

  # Maximum value within the filtered dataset
  max: Float

  # Minimum value within the filtered dataset
  min: Float
}

type GqlModule {
  # User facing description for the module
  description: String

  # Unique identifier for the module
  id: String

  # Bundle last modification date
  lastModified: Long

  # User facing name for the module
  name: String

  # Version number for the module
  version: String

  # If the module is in development, mostly because the sources have been downloaded.
  inDevelopment: Boolean
}

# Possible operations on a node
type GqlOperationsSupport {
  # Can node be locked
  lock: Boolean

  # Can node be marked for deletion
  markForDeletion: Boolean

  # does the node supports publication
  publication: Boolean!
}

# Model of a plugin information (name,description,version)
type GqlPlugin {
  # Full description of the plugin
  description: String

  # Full name of the plugin
  name: String

  # version of the plugin
  version: String
}

type GqlProbe {
  # Description specified by the developer of the probe
  description: String

  # Name of the probe
  name: String

  # Severity of the probe (LOW to CRITICAL)
  severity: GqlProbeSeverity

  # Status reported by the probe (GREEN to RED)
  status: GqlProbeStatus
}

enum GqlProbeHealth {
  # GREEN
  GREEN

  # YELLOW
  YELLOW

  # RED
  RED
}

enum GqlProbeSeverity {
  # LOW
  LOW

  # MEDIUM
  MEDIUM

  # HIGH
  HIGH

  # CRITICAL
  CRITICAL
}

# Probe status
type GqlProbeStatus {
  # Health of the probe
  health: GqlProbeHealth

  # Message explaining probe status
  message: String
}

# Publication status information for a JCR node
type GqlPublicationInfo {
  # Whether node exists in live workspace
  existsInLive: Boolean

  # Aggregated publication status of the node
  publicationStatus: PublicationStatus!

  # Whether current user is allowed to publish the node omitting any workflows
  allowedToPublishWithoutWorkflow: Boolean

  # Aggregated locked status of the node
  locked: Boolean

  # Aggregated work-in-progress status of the node
  workInProgress: Boolean
}

# Representation of range facet aggregation buckets
type GqlRangeFacetData {
  # Number of documents matching the range
  count: Int

  # Name provided for the range
  name: String
}

# Result of aggregation based on field and ranges
type GqlRangeFacetResult {
  # Data based on facets specified in the search
  data: [GqlRangeFacetData]

  # The field that was used to run the aggregation
  field: String
}

# API Scope
type GqlScope {
  # The description of the scope
  description: String

  # The name of the scope
  name: String
}

union GqlSearchFacetValue = DateRangeValue | NumberRangeValue | TermValue

# Container for search operations
type GqlSearchQueryExtension {
  # Retrieves nodes matching a search
  search(
    # Search query
    q: String!

    # Where to search, can be CONTENT or FILES
    searchIn: [SearchIn]

    # Limit of pages displayed
    limit: Int

    # Offset, total offset is calculated by multiplying offset number by limit
    offset: Int

    # Facets specification
    facets: Inputfacets

    # Sorting specification
    sortBy: InputSort

    # Filtering specification
    filter: Inputfilter
  ): searchResults
    @deprecated(reason: "This will be removed in future versions")
}

type GqlSession {
  cost: Long
  creationTime: String
  id: String
  lastAccessedTime: String
  maxInactiveIntervalInSeconds: Int
  partition: GqlHzPartition
  user: User
}

# A connection to a list of items.
type GqlSessionConnection {
  # a list of nodes
  nodes: [GqlSession]

  # a list of edges
  edges: [GqlSessionEdge]

  # details about this specific page
  pageInfo: PageInfo!
}

# An edge in a connection
type GqlSessionEdge {
  # The item at the end of the edge
  node: GqlSession

  # cursor marks a unique position or index into the connection
  cursor: String!

  # index in the connection
  index: Int
}

# Sharding configuration details
type GqlShardConfiguration {
  # Average shard size, based on the current index size
  averageShardSize: Long

  # Available heap memory per shard
  heapPerShard: Long

  # Number of primary shards
  primaryCount: Int

  # Number of replicas
  replicas: Int

  # Is the number of shards evenly divisible by number of data nodes
  divisible: Boolean
}

# Aggregation bucket representation
type GqlTermFacetData {
  # The aggregation bucket value
  count: Int

  # The aggregation bucket value
  value: String
}

# Result of aggregation based on field
type GqlTermFacetResult {
  # Data based on facets specified in the search
  data: [GqlTermFacetData]

  # The field that was used to run the aggregation
  field: String
}

# Children data of tree facet root value
type GqlTreeFacetData {
  # Number of documents
  count: Int

  # Filter expression to find matching results for this path
  filter: String

  # Human Readable path
  humanPath: String

  # key of this facet
  key: String

  # System path to be used in root path for tree facets
  rootPath: String

  # The aggregation bucket value
  value: String

  # Indicate whether the tree element has any children
  hasChildren: Boolean
}

# Result of hierarchical facet aggregation
type GqlTreeFacetResult {
  # Data based on facets specified in the search
  data: [GqlTreeFacetData]

  # The field that was used to run the aggregation
  field: String

  # rootPath passed as a parameter
  rootPath: String
}

type GqljExperience {
  # Get jExperience configurations
  config(siteKey: String): GqljExperienceConfigQuery

  # Get the list of all the jExperience experience types that exist in the current environment
  experienceTypes: [GqlExperienceType]
}

type GqljExperienceConfigMutation {
  # Set the tracker allowed origins
  trackerOriginConfig(origins: [String]): [String]
}

type GqljExperienceConfigQuery {
  # Get the tracker allowed origins
  trackerOriginConfig: [String]
}

type GqljExperienceMutation {
  config(siteKey: String): GqljExperienceConfigMutation
}

# GraphQL representation of a Jahia group
type Group implements Principal {
  # Full display name
  displayName: String

  # List of groups this principal belongs to
  groupMembership(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Return only groups which belong to this site
    site: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput
  ): GroupConnection!

  # Group members
  members(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput
  ): PrincipalConnection!

  # Group name
  name: String!

  # Get the corresponding JCR node
  node: JCRNode

  # Group property
  property(
    # The name of the property
    name: String!
  ): String

  # Site where the group is defined
  site: JCRSite

  # Is this principal member of the specified group
  memberOf(
    # Target group
    group: String

    # Site where the group is defined
    site: String
  ): Boolean
}

# A connection to a list of items.
type GroupConnection {
  # a list of nodes
  nodes: [Group]

  # a list of edges
  edges: [GroupEdge]

  # details about this specific page
  pageInfo: PageInfo!
}

# An edge in a connection
type GroupEdge {
  # The item at the end of the edge
  node: Group

  # cursor marks a unique position or index into the connection
  cursor: String!

  # index in the connection
  index: Int
}

enum GroupingType {
  # Put grouped items at the end in the order groups appear in the 'groups' list
  END

  # Put grouped items at the start in the order groups appear in the 'groups' list
  START
}

# Asset type for image
type ImageAsset {
  # Asset metadata
  metadata: Metadata

  # Mime type of image
  type: String

  # Image size
  size: Long

  # Image height
  height: Long

  # Image width
  width: Long
}

# Info about a node to be reproduced at (moved or copied to) another parent node
input InputCarriedJCRNode {
  # The name of the node at the new location or null if its current name should be preserved
  destName: String

  # Path or UUID of the destination parent node to copy/move the node to
  destParentPathOrId: String!

  # Path or UUID of the node to be copied/moved
  pathOrId: String!
}

input InputContextEntryInput {
  key: String
  value: [String]
}

# Input object representing either a sub-filter (so that nested conditional logic can be composed), or a condition to filter by a single field
input InputFieldFilterInput {
  # The way to evaluate the property; null indicates default (EQUAL)
  evaluation: FieldEvaluation

  # Either a non-null sub-filter, or null in case the input object represents a simple field filter configured via its other properties
  fieldFilter: InputFieldFiltersInput

  # The name of the field or its alias to filter by
  fieldName: String

  # The value to evaluate the field against (for single-valued operations)
  value: String

  # The values to evaluate the field against (for multi-valued operations)
  values: [String]
}

# Filter any GraphQL node based on a sub-fields values
input InputFieldFiltersInput {
  # Individual property filters
  filters: [InputFieldFilterInput]!

  # The way to combine multiple individual property filters; null indicates default (ALL)
  multi: MulticriteriaEvaluation
}

# Group entries according to criteria
input InputFieldGroupingInput {
  # fieldName to group on
  fieldName: String!

  # grouping type
  groupingType: GroupingType!

  # specified groups
  groups: [String]!
}

# object with fieldName and sort direction (ASC/DESC)
input InputFieldSorterInput {
  # fieldName to sort
  fieldName: String

  # direction of the sort
  sortType: SortType

  # ignore case when sorting
  ignoreCase: Boolean
}

# An optional part of the JCR node criteria to filter nodes, specifically by their arbitrary properties
input InputGqlJcrNodeConstraintInput {
  # A list of child constraint input for all composition
  all: [InputGqlJcrNodeConstraintInput]

  # A list of child constraint input for any composition
  any: [InputGqlJcrNodeConstraintInput]

  # A search expression to match the node property value(s) against, either specific property only or all node properties, dependent on the 'property' parameter value passed
  contains: String

  # A value to compare the node property value to, using the 'equals to' operator
  equals: String

  # A value to compare the node property value to, using the 'exists' operator
  exists: Boolean

  # The query function name for the node for comparison
  function: QueryFunction

  # A value to compare the node property value to, using the 'greater than' operator
  gt: String

  # A value to compare the node property value to, using the 'greater than or equals to' operator
  gte: String

  # A value to pick the last days for node property date value, using the 'lastDays' operator
  lastDays: Int

  # A value to compare the node property value to, using the 'like' operator
  like: String

  # A value to compare the node property value to, using the 'less than' operator
  lt: String

  # A value to compare the node property value to, using the 'less than or equals to' operator
  lte: String

  # A list of child constraint input for none composition
  none: [InputGqlJcrNodeConstraintInput]

  # A value to compare the node property value to, using the 'not equals to' operator
  notEquals: String

  # The name of the node property to compare/match; may be null when optional or not applicable, dependent on other parameter values
  property: String
}

# Node criterias
input InputGqlJcrNodeCriteriaInput {
  # Language to access node properties in
  language: String

  # Additional constraint to filter nodes by their arbitrary properties
  nodeConstraint: InputGqlJcrNodeConstraintInput

  # The type of nodes to query
  nodeType: String!

  # Ordering strategies
  ordering: InputGqlOrdering

  # The exact meaning of the paths field
  pathType: PathType

  # Paths that restrict areas to fetch nodes from; the exact meaning is defined by the pathType field; null or empty collection means no path restrictions
  paths: [String]
}

# Ordering
input InputGqlOrdering {
  # ASC or DESC order
  orderType: OrderType

  # The property to order by
  property: String
}

# Tree facet input object
input InputGqlTreeFacet {
  # value of the root of hierarchical tree
  rootValue: String

  # Term facet
  termFacet: InputTermFacet
}

# GraphQL representation of a JCR node to be created
input InputJCRNode {
  # The collection of sub nodes to create
  children: [InputJCRNode]

  # The collection of mixins to add to the node
  mixins: [String]

  # The name of the node to create
  name: String!

  # The primary node type of the node to create
  primaryNodeType: String!

  # The collection of properties to set to the node
  properties: [InputJCRProperty]

  # If true, use the next available name for a node, appending if needed numbers. Default is false
  useAvailableNodeName: Boolean
}

# GraphQL representation of a JCR node to be created
input InputJCRNodeWithParent {
  # The collection of sub nodes to create
  children: [InputJCRNode]

  # The collection of mixins to add to the node
  mixins: [String]

  # The name of the node to create
  name: String!

  # The parent path or id where the node will be created
  parentPathOrId: String!

  # The primary node type of the node to create
  primaryNodeType: String!

  # The collection of properties to set to the node
  properties: [InputJCRProperty]

  # If true, use the next available name for a node, appending if needed numbers. Default is false
  useAvailableNodeName: Boolean
}

# GraphQL representation of a JCR property to set
input InputJCRProperty {
  # The language in which the property will be set (for internationalized properties
  language: String

  # The name of the property to set
  name: String!

  # The option of the property
  option: JCRPropertyOption

  # The type of the property
  type: JCRPropertyType

  # The value to set (for single valued properties)
  value: String

  # The values to set (for multivalued properties)
  values: [String]
}

# Metrics facet to filter by specific field
input InputMetricsFacet {
  # Field the facet is applied on.
  field: String!

  # Maximum number of facet groups returned. Default is 10.
  max: Int

  # Whether the facet filter will be OR (set to true) or AND (set to false). Default is false.
  disjunctive: Boolean
}

# Node properties selection
input InputNodePropertiesInput {
  # The way to combine multiple individual property filters; null indicates default (ALL)
  multi: MulticriteriaEvaluation

  # Individual property filters
  filters: [InputNodePropertyInput]!
}

# Node property selection
input InputNodePropertyInput {
  # Language to use when evaluating the property
  language: String

  # The way to evaluate the property; null indicates default (EQUAL)
  evaluation: PropertyEvaluation

  # The name of the property to filter by
  property: String!

  # The value to evaluate the property against
  value: String
}

# Node types selection
input InputNodeTypesInput {
  # The way to combine multiple type criteria; null indicates default (ANY)
  multi: MulticriteriaEvaluation

  # Node type names required for a node to pass the filter
  types: [String]!
}

# Input for nodetypes list
input InputNodeTypesListInput {
  # Consider sub-types when checking for included/excluded nodetypes (default true)
  considerSubTypes: Boolean

  # Exclude the types, specified by this list (also considering sub-types, if considerSubTypes is true)
  excludeTypes: [String]

  # Include abstract types (default true)
  includeAbstract: Boolean

  # Include mixin types (default true)
  includeMixins: Boolean

  # Include non mixin types (default true)
  includeNonMixins: Boolean

  # Only include types specified by this list (also considering sub-types, if considerSubTypes is true)
  includeTypes: [String]

  # Filter on nodetypes defined in these modules
  modules: [String]

  # Consider only nodetypes for the specified site
  siteKey: String
}

# Number Range Input Object
input InputNumberRange {
  # Greater than a number
  gt: Float

  # Greate than or equal to a number
  gte: Float

  # Less than a number
  lt: Float

  # Less than or equal to a number
  lte: Float

  # Name to describe the facet
  name: String!
}

# Number Range facet to filter on specified ranges
input InputNumberRangeFacet {
  # Field the facet is applied on.
  field: String!

  # Maximum number of facet groups returned. Default is 10.
  max: Int

  # List of available ranges to be used
  ranges: [InputNumberRange]!

  # Selected groups. Default is [].
  selections: [InputNumberRange]

  # Whether the facet filter will be OR (set to true) or AND (set to false). Default is false.
  disjunctive: Boolean
}

# Number Range Input Object
input InputRange {
  # From value [used in Range facet]
  from: String

  # Name to describe the facet
  name: String!

  # To value [used in Range facet]
  to: String
}

# Range facet to filter on specified ranges
input InputRangeFacet {
  # Field the facet is applied on.
  field: String!

  # Maximum number of facet groups returned. Default is 10.
  max: Int

  # List of available ranges to be used
  ranges: [InputRange]!

  # Selected groups. Default is [].
  selections: [InputRange]

  # Whether the facet filter will be OR (set to true) or AND (set to false). Default is false.
  disjunctive: Boolean
}

# Request attribute that can be use by rendering API
input InputRenderRequestAttributeInput {
  # The name of the request attribute
  name: String!

  # The value of the request attribute
  value: String!
}

# Sort object for ordering or results
input InputSort {
  # ASC or DESC order
  orderType: SortOrder!

  # The property to order by
  property: String!
}

# Term facet to filter on specific selections
input InputTermFacet {
  # Field the facet is applied on.
  field: String!

  # Maximum number of facet groups returned. Default is 10.
  max: Int

  # Minimum number of documents for a value to return as a facet. Default is 5.
  minDocCount: Int

  # Label to be used for missing values on this field. If not specified, missing fields will not be counted
  missingValue: String

  # Selected groups. Default is [].
  selections: [String]

  # Whether the facet filter will be OR (set to true) or AND (set to false). Default is false.
  disjunctive: Boolean
}

input InputVanityUrl {
  # The language of the content object to which the vanity URL maps to
  language: String!

  # The vanity URL
  url: String!

  # true if the URL mapping is activated or false if it is not activated
  active: Boolean

  # true whether this URL mapping is the default one for the language
  defaultMapping: Boolean!
}

# Boost fields for document matching
input Inputboost {
  # Boost configuration for fields and subfields. Overrides content, main and metadata boosts if present. Unspecified fields receive a default value as specified in .cfg file.
  boosts: InputboostConfig

  # Boost document based on their content(rich text, simple text) matching
  content: Float

  # Boost document based on their main field (displayableName, title) matching
  main: Float

  # Boost document based on their metadata field (tags, keywords, categories) matching
  metadata: Float
}

# Boost configuration for fields and their subfields
input InputboostConfig {
  # Boost for jgql:content field multimatch query
  content: InputboostSpec

  # Boost for jgql:file_content field multimatch query. Note that stem and ngram field boosts are not taken into account.
  file: InputboostSpec

  # Boost for jgql:main field multimatch query
  main: InputboostSpec

  # Boost for jgql:metadata field multimatch query
  metadata: InputboostSpec
}

# Boost specification for multimatch query against a field
input InputboostSpec {
  # Boost for default field
  defaultField: Float

  # Boost for ngram field
  ngram: Float

  # Boost for phrase field
  phrase: Float

  # Overall boost for multimatch query (default field and subfields as a group)
  query: Float

  # Boost for stem field
  stem: Float
}

# A set of applicable facets
input Inputfacets {
  # Date range facet to be used during search
  dateRange: [InputRangeFacet]

  # Metrics facet to be used during search
  metrics: [InputMetricsFacet]

  # Range facet to be used during search
  numberRange: [InputNumberRangeFacet]

  # Term facet to be used during search
  term: [InputTermFacet]

  # Metrics facet to be used during search
  tree: [InputGqlTreeFacet]
}

# Search filter
input Inputfilter {
  # Author filter
  author: String

  # Created filter
  created: InputfilterRange

  # Custom filters
  custom: InputfilterGroups

  # Modified filter
  modified: InputfilterRange

  # Node type filter
  nodeType: InputnodeTypeFilter

  # Node path filter
  path: String

  # Published filter
  published: InputfilterRange
}

# Custom term input object
input InputfilterCustomTerm {
  # Mapped field to filter on
  field: String!

  # Value to filter
  value: String!
}

# Custom date range group
input InputfilterDateRangeGroup {
  # AND or OR filter operation
  operation: Operation

  # Ranges used for filtering
  ranges: [InputfilterExtendedDateRange]!
}

# Custom extended date range input object
input InputfilterExtendedDateRange {
  # To display hits after specified date
  after: String

  # To display hits before specified date
  before: String

  # Filter for strict equality to the date
  equal: String

  # Field to filter by
  field: String!
}

# Custom filter groups
input InputfilterGroups {
  # Groups of date range filters
  dateRange: [InputfilterDateRangeGroup]

  # Groups of number range filters
  numberRange: [InputfilterNumberRangeGroup]

  # Groups of term filters
  term: [InputfilterTermGroup]
}

# Number range input object
input InputfilterNumberRange {
  # Numeric field to filter by
  field: String!

  # Greater than a number
  gt: Float

  # Greater than or equal to number
  gte: Float

  # Less than a number
  lt: Float

  # Less than or equal to number
  lte: Float
}

# Custom number range group
input InputfilterNumberRangeGroup {
  # Filter operation
  operation: Operation

  # Ranges
  ranges: [InputfilterNumberRange]!
}

# Range input object
input InputfilterRange {
  # To display hits after specified date
  after: String

  # To display hits before specified date
  before: String

  # Filter for strict equality to the date
  equal: String
}

# Custom filter term group
input InputfilterTermGroup {
  # Filter operation
  operation: Operation

  # Terms to filter by
  terms: [InputfilterCustomTerm]!
}

# Filter for filtering on node type
input InputnodeTypeFilter {
  # Node type
  type: String

  # Flag to determine if sub node types should be included in filter
  includeSubNodes: Boolean
}

# Sort object for ordering or results
input InputsortV2 {
  # Direction in which ordering occurs
  dir: OrderDirection!

  # The field to order by
  field: String!
}

# Work in progress information
input InputwipInfo {
  # The languages set for Work in progress
  languages: [String]

  # Get WIP status
  status: WipStatus
}

# GraphQL representation of a JCR item definition
interface JCRItemDefinition {
  # Gets the node type that contains the declaration of this definition.
  declaringNodeType: JCRNodeType!

  # Gets the name of the child item.
  name: String!

  # Reports whether the item is to be automatically created when its parent node is created.
  autoCreated: Boolean!

  # Reports whether the child item is hidden from UI.
  hidden: Boolean!

  # Reports whether the item is mandatory. A mandatory item is one that, if its parent node exists, must also exist.
  mandatory: Boolean!

  # Reports whether the child item is protected.
  protected: Boolean!
}

# JCR Mutations
type JCRMutation {
  # Creates a new JCR node under the specified parent
  addNode(
    # The path or id of the parent node
    parentPathOrId: String!

    # The name of the node to create
    name: String!

    # The primary node type of the node to create
    primaryNodeType: String!

    # If true, use the next available name for a node, appending if needed numbers. Default is false
    useAvailableNodeName: Boolean

    # The collection of mixin type names
    mixins: [String]
    properties: [InputJCRProperty]
    children: [InputJCRNode]
  ): JCRNodeMutation

  # Batch creates a number of new JCR nodes under the specified parent
  addNodesBatch(
    # The collection of nodes to create
    nodes: [InputJCRNodeWithParent]!
  ): [JCRNodeMutation]

  # Copy a single node to a different parent node
  copyNode(
    # Path or UUID of the node to be copied
    pathOrId: String!

    # Path or UUID of the destination parent node to copy the node to
    destParentPathOrId: String!

    # The name of the node at the new location or null if its current name should be preserved
    destName: String
  ): JCRNodeMutation

  # Copy multiple nodes to different parent node(s)
  copyNodes(nodes: [InputCarriedJCRNode!]!): [JCRNodeMutation]

  # Delete an existing node and all its children
  deleteNode(
    # The path or id of the node to delete
    pathOrId: String!
  ): Boolean

  # Get a collection of nodes that were modified by current GraphQL request
  modifiedNodes: [JCRNode]

  # Import a file under the specified parent
  importContent(
    # The path or id of the parent node
    parentPathOrId: String!

    # Name of the request part that contains desired import file body
    file: String!

    # Specify the behaviour in case of existing content, possible values are in the DocumentViewImportHandler class
    rootBehaviour: Int = 2
  ): Boolean

  # Marks the existing node and all its children for deletion
  markNodeForDeletion(
    # The path or id of the node to mark for deletion
    pathOrId: String!

    # Optional deletion comment
    comment: String
  ): Boolean

  # Move a single node to a different parent node
  moveNode(
    # Path or UUID of the node to be moved
    pathOrId: String!

    # Path or UUID of the destination parent node to move the node to
    destParentPathOrId: String!

    # The name of the node at the new location or null if its current name should be preserved
    destName: String
  ): JCRNodeMutation

  # Move multiple nodes to different parent node(s)
  moveNodes(nodes: [InputCarriedJCRNode!]!): [JCRNodeMutation]

  # Mutates an existing node, based on path or id
  mutateNode(
    # The path or id of the node to mutate
    pathOrId: String!
  ): JCRNodeMutation

  # Mutates a set of existing nodes, based on path or id
  mutateNodes(
    # The paths or id ofs the nodes to mutate
    pathsOrIds: [String]!
  ): [JCRNodeMutation]

  # Mutates a set of existing nodes, based on query execution
  mutateNodesByQuery(
    # The query string
    query: String!

    # The query language
    queryLanguage: QueryLanguage = SQL2

    # The maximum size of the result set
    limit: Long

    # The start offset of the result set
    offset: Long
  ): [JCRNodeMutation]

  # Unmarks the specified node and all its children for deletion
  unmarkNodeForDeletion(
    # The path or id of the node to unmark for deletion
    pathOrId: String!
  ): Boolean

  # Paste a single node to a different parent node
  pasteNode(
    # Paste mode, either COPY or MOVE
    mode: PasteMode!

    # Path or UUID of the node to be pasted
    pathOrId: String!

    # Path or UUID of the destination parent node to paste the node to
    destParentPathOrId: String!

    # The name of the node at the new location or null if its current name should be preserved
    destName: String

    # The way to deal with duplicate node names when they are not allowed, either FAIL or RENAME
    namingConflictResolution: NodeNamingConflictResolutionStrategy = FAIL
  ): JCRNodeMutation

  # Paste multiple nodes to different parent node(s)
  pasteNodes(
    # Paste mode, either COPY or MOVE
    mode: PasteMode!

    # Info about nodes to paste and their new parent node(s)
    nodes: [InputCarriedJCRNode!]!

    # The way to deal with duplicate node names when they are not allowed, either FAIL or RENAME
    namingConflictResolution: NodeNamingConflictResolutionStrategy = FAIL
  ): [JCRNodeMutation]

  # Vanity URL Mutation
  mutateVanityUrls(
    # Paths or UUIDs of vanity URL nodes to mutate
    pathsOrIds: [String]!
  ): [VanityUrlMappingMutation]
}

# GraphQL representation of a JCR node
interface JCRNode {
  # Get the last modified date of this node and its descendants. The recursion in descendants can be controlled by recursionTypesFilter. If no filter is passed, recursion will stop by default on sub pages.
  aggregatedLastModifiedDate(
    # The language to use to get the last modified date, if not specified, returns last modification date in any language
    language: String

    # Stop recursion on nodes by their types; null to avoid such filtering
    recursionTypesFilter: InputNodeTypesInput
  ): String

  # GraphQL representations of the ancestor nodes of the JCR node, top down direction
  ancestors(
    # The path of the topmost ancestor node to include in the result; null or empty string to include all the ancestor nodes
    upToPath: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNode]!

  # GraphQL representations of the child nodes, according to parameters passed
  children(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter of child nodes by their names; null to avoid such filtering
    names: [String]

    # Language to use to get children
    validInLanguage: String

    # Filter of child nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Filter of child nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput

    # Include the current node itself in results
    includesSelf: Boolean = false
  ): JCRNodeConnection

  # GraphQL representation of a descendant node, based on its relative path
  descendant(
    # Name or relative path of the sub node
    relPath: String!
  ): JCRNode

  # GraphQL representations of the descendant nodes, according to parameters passed
  descendants(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter of descendant nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Language to use to get children
    validInLanguage: String

    # Filter of descendant nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput

    # Filter out and stop recursion on nodes by their types; null to avoid such filtering
    recursionTypesFilter: InputNodeTypesInput

    # Filter out and stop recursion on nodes by their property values; null to avoid such filtering
    recursionPropertiesFilter: InputNodePropertiesInput

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput
  ): JCRNodeConnection

  # The display name of the JCR node this object represents in the requested language
  displayName(
    # The language to obtain the display name in
    language: String
  ): String

  # Check if the given locales need translation, by comparing last modifications dates with already existing translations
  languagesToTranslate(
    # List of known translated languages, will be used to compare modifications dates
    languagesTranslated: [String]

    # List of languages potentially to be translated
    languagesToCheck: [String]
  ): [String]

  # The name of the JCR node this object represents
  name: String!

  # GraphQL representation of this node in certain workspace
  nodeInWorkspace(
    # The target workspace
    workspace: Workspace!
  ): JCRNode

  # Get information on the operations that can be done on this node
  operationsSupport: GqlOperationsSupport

  # GraphQL representation of the parent JCR node
  parent: JCRNode

  # The path of the JCR node this object represents
  path: String!

  # GraphQL representations of the properties in the requested language
  properties(
    # The names of the JCR properties; null to obtain all properties
    names: [String]

    # The language to obtain the properties in; must be a valid language code in case any internationalized properties are requested, does not matter for non-internationalized ones
    language: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRProperty]!

  # The GraphQL representation of the property in the requested language; null if the property does not exist
  property(
    # The name of the JCR property
    name: String!

    # The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
    language: String
  ): JCRProperty

  # GraphQL representations of the reference properties that target the current JCR Node
  references(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): JCRPropertyConnection!

  # The UUID of the JCR node this object represents
  uuid: String!

  # Get the workspace of the query
  workspace: Workspace!

  # Check if the current user has a specific permission
  hasPermission(
    # The name of the permission
    permissionName: String!
  ): Boolean

  # Read default Work in progress information. Set by "wip.checkbox.checked" system proprety
  defaultWipInfo: wipInfo

  # Read work in progress information for a given node
  wipInfo: wipInfo

  # Get vanity URLs from the current node filtered by the parameters
  vanityUrls(
    # Languages
    languages: [String]

    # Filter results based on graphql field values
    fieldFilter: InputFieldFiltersInput
  ): [VanityUrl]

  # Retrieve lock info of the current node
  lockInfo: LockInfo

  # Aggregated publication info about the JCR node
  aggregatedPublicationInfo(
    # Publication language
    language: String!

    # Whether to take sub-nodes into account when calculating the aggregated publication status
    subNodes: Boolean = false

    # Whether to take references into account when calculating the aggregated publication status
    references: Boolean = false
  ): GqlPublicationInfo!

  # Give access to the experience fields for the current node
  asExperience: GqlExperience
  jExperience(
    # Unomi profile id
    profileId: String

    # Unomi session id
    sessionId: String
  ): PersonalizedResult

  # Render URL in ajax mode
  ajaxRenderUrl: String

  # Returns the first parent of the current node that can be displayed in full page. If no matching node is found, null is returned.
  displayableNode: JCRNode

  # Gets the fully rendered content for this node
  renderedContent(
    # Name of the view
    view: String

    # Template type
    templateType: String

    # Rendering context configuration
    contextConfiguration: String

    # Language
    language: String

    # Main resource path
    mainResourcePath: String

    # Is edit mode
    isEditMode: Boolean

    # Additional request attributes
    requestAttributes: [InputRenderRequestAttributeInput]
  ): RenderedNode

  # Check if the node as a renderable template associated with it (not a view a template).
  isDisplayableNode: Boolean

  # GraphQL representation of the site the JCR node belongs to, or the system site in case the node does not belong to any site
  site: JCRSite

  # Returns the next available name for a node, appending if needed numbers.
  findAvailableNodeName(nodeType: String, language: String): String

  # Returns edit lock status of the current node object
  lockedAndCannotBeEdited: Boolean

  # Returns a list of types allowed under the provided node
  allowedChildNodeTypes(
    # Whether all sub-types of allowed child node types should be included
    includeSubTypes: Boolean = true

    # Filter by GraphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeType]

  # Returns the node definition that applies to this node.
  definition: JCRNodeDefinition

  # Returns an array of <code>NodeType</code> objects representing the mixin node types in effect for this node.
  mixinTypes(
    # Filter by GraphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeType]!

  # Get the primary node type of this node
  primaryNodeType: JCRNodeType!

  # Reports if the current node matches the nodetype(s) passed in parameter
  isNodeType(
    # Node type name
    type: InputNodeTypesInput!
  ): Boolean!
}

# Aggregations on JCR Nodes
type JCRNodeAggregation {
  # Average aggregation
  avg: StatAggregation

  # Count aggregation
  count: CountAggregation

  # Max aggregation
  max: StatAggregation

  # Min aggregation
  min: StatAggregation

  # Sum aggregation
  sum: StatAggregation
}

# A connection to a list of items.
type JCRNodeConnection {
  # a list of nodes
  nodes: [JCRNode]

  # a list of edges
  edges: [JCRNodeEdge]

  # details about this specific page
  pageInfo: PageInfo!

  # Get an aggregation by fields on nodes of this connection
  aggregation: JCRNodeAggregation
}

# GraphQL representation of a JCR node definition
type JCRNodeDefinition implements JCRItemDefinition {
  # Reports whether this child node can have same-name siblings. In other words, whether the parent node can have more than one child node of this name.
  allowsSameNameSiblings: Boolean!

  # Gets the node type that contains the declaration of this definition.
  declaringNodeType: JCRNodeType!

  # Gets the default primary node type that will be assigned to the child node if it is created without an explicitly specified primary node type.
  defaultPrimaryType: JCRNodeType

  # Gets the name of the child item.
  name: String!

  # Gets the minimum set of primary node types that the child node must have.
  requiredPrimaryType: [JCRNodeType]

  # Reports whether the item is to be automatically created when its parent node is created.
  autoCreated: Boolean!

  # Reports whether the child item is hidden from UI.
  hidden: Boolean!

  # Reports whether the item is mandatory. A mandatory item is one that, if its parent node exists, must also exist.
  mandatory: Boolean!

  # Reports whether the child item is protected.
  protected: Boolean!
}

# An edge in a connection
type JCRNodeEdge {
  # The item at the end of the edge
  node: JCRNode

  # cursor marks a unique position or index into the connection
  cursor: String!

  # index in the connection
  index: Int
}

# Mutations on a JCR node
type JCRNodeMutation {
  # Creates a new JCR node under the current node
  addChild(
    # The name of the node to create
    name: String!

    # The primary node type of the node to create
    primaryNodeType: String!

    # If true, use the next available name for a node, appending if needed numbers. Default is false
    useAvailableNodeName: Boolean

    # The collection of mixin type names
    mixins: [String]
    properties: [InputJCRProperty]
    children: [InputJCRNode]
  ): JCRNodeMutation

  # Batch creates a number of new JCR nodes under the current node
  addChildrenBatch(
    # The collection of nodes to create
    nodes: [InputJCRNode]!
  ): [JCRNodeMutation]

  # Adds mixin types on the current node
  addMixins(
    # The collection of mixin type names
    mixins: [String]!
  ): [String]

  # Delete the current node (and its subgraph)
  delete: Boolean

  # Get the graphQL representation of the node currently being mutated
  node: JCRNode

  # Get the identifier of the node currently being mutated
  uuid: String

  # Import a file under the current node
  importContent(
    # Name of the request part that contains desired import file body
    file: String!
  ): Boolean

  # Mark the current node (and its subgraph) for deletion
  markForDeletion(
    # Optional deletion comment
    comment: String
  ): Boolean

  # Moves the current node to a specified destination path (if destPath is specified) or moves it under the specified node (if parentPathOrId is specified). Either of two parameters is expected.
  move(
    # The target node path of the current node after the move operation
    destPath: String

    # The parent node path or id under which the current node will be moved to
    parentPathOrId: String
  ): String

  # Mutates a set of existing direct sub nodes, based on filters passed as parameter
  mutateChildren(
    # Filter of child nodes by their names; null to avoid such filtering
    names: [String]

    # Filter of child nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Filter of child nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput
  ): [JCRNodeMutation]

  # Mutates an existing sub node, based on its relative path to the current node
  mutateDescendant(
    # Name or relative path of the sub node to mutate
    relPath: String!
  ): JCRNodeMutation

  # Mutates a set of existing descendant nodes, based on filters passed as parameter
  mutateDescendants(
    # Filter of descendant nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Filter of descendant nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput

    # Filter out and stop recursion on nodes by their types; null to avoid such filtering
    recursionTypesFilter: InputNodeTypesInput

    # Filter out and stop recursion on nodes by their property values; null to avoid such filtering
    recursionPropertiesFilter: InputNodePropertiesInput
  ): [JCRNodeMutation]

  # Mutates or creates a set of properties on the current node
  mutateProperties(
    # The names of the JCR properties; null to obtain all properties
    names: [String]
  ): [JCRPropertyMutation]

  # Mutates or creates a property on the current node
  mutateProperty(
    # The name of the property to update
    name: String!
  ): JCRPropertyMutation

  # Removes mixin types on the current node
  removeMixins(
    # The collection of mixin type names
    mixins: [String]!
  ): [String]

  # Rename the current node
  rename(
    # The new name of the node
    name: String!
  ): String

  # Reorder child nodes according to the list of names passed
  reorderChildren(
    # List of child node names in the desired order
    names: [String]!

    # The target position of reordered child nodes. The default value is inplace.
    position: ReorderedChildrenPosition = INPLACE
  ): Boolean

  # Mutates or creates a set of properties on the current node
  setPropertiesBatch(
    # The collection of JCR properties to set
    properties: [InputJCRProperty]
  ): [JCRPropertyMutation]

  # Return image transformation mutation
  transformImage(
    # name of target file, if different
    name: String

    # target path, if different
    targetPath: String
  ): GqlJcrImageTransformMutation

  # Unmark this node and all the sub-nodes for deletion
  unmarkForDeletion: Boolean

  # Return zip mutation
  zip: ZipFileMutation

  # Unlock all nodes under the specified node
  clearAllLocks: Boolean

  # Lock the node
  lock(
    # Type of lock, defaults to user
    type: String = "user"
  ): Boolean

  # Unlock the node
  unlock(
    # Type of lock, defaults to user
    type: String = "user"
  ): Boolean

  # Add vanity URL
  addVanityUrl(
    # The list of vanity url to create
    vanityUrlInputList: [InputVanityUrl]!
  ): [VanityUrlMappingMutation]

  # Update a vanity URL
  mutateVanityUrl(
    # The url to edit
    url: String!
  ): VanityUrlMappingMutation

  # Update vanity URLs
  mutateVanityUrls(
    # Filter by languages
    languages: [String]
  ): [VanityUrlMappingMutation]
  startWorkflow(definition: String, language: String): Boolean

  # Add wip information
  createWipInfo(
    # Work in progress information to save
    wipInfo: InputwipInfo!
  ): Boolean

  # Mutate wip information
  mutateWipInfo(
    # Work in progress information to save
    wipInfo: InputwipInfo!
  ): Boolean

  # Publish the node in certain languages
  publish(
    # Languages to publish the node in
    languages: [String]

    # Publish all sub and related nodes. Default is true.
    publishSubNodes: Boolean = true

    # Publish all sub tree including sub pages. Default is false.
    includeSubTree: Boolean = false
  ): Boolean

  # Unpublish the node in certain languages
  unpublish(
    # Languages to publish the node in
    languages: [String]
  ): Boolean
}

# GraphQL representation of a JCR node type
type JCRNodeType {
  # Node type displayable name
  displayName(
    # Language
    language: String!
  ): String

  # Node type icon
  icon: String

  # Node type name
  name: String

  # Returns an array containing the child node definitions of this node type.
  nodes(
    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeDefinition]

  # Returns the name of the primary item (one of the child items of the nodes of this node type). If this node has no primary item, then this method null.
  primaryItem: JCRItemDefinition

  # Returns an array containing the property definitions of this node type.
  properties(
    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRPropertyDefinition]

  # Returns all subtypes of this node type in the node type inheritance hierarchy.
  subTypes(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int
  ): JCRNodeTypeConnection

  # Returns all supertypes of this node type in the node type inheritance hierarchy.
  supertypes(
    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeType]

  # System ID of the node type, corresponding to the name of the module declaring it.
  systemId: String

  # Returns true if this is an abstract node type; returns false otherwise.
  abstract: Boolean

  # Returns true if nodes of this type must support orderable child nodes; returns false otherwise.
  hasOrderableChildNodes: Boolean

  # Returns true if this is a mixin type; returns false otherwise.
  mixin: Boolean

  # Reports if the current node type matches the nodetype(s) passed in parameter
  isNodeType(
    # Node type name
    type: InputNodeTypesInput!
  ): Boolean!

  # Returns true if the node type is queryable.
  queryable: Boolean
}

# A connection to a list of items.
type JCRNodeTypeConnection {
  # a list of nodes
  nodes: [JCRNodeType]

  # a list of edges
  edges: [JCRNodeTypeEdge]

  # details about this specific page
  pageInfo: PageInfo!
}

# An edge in a connection
type JCRNodeTypeEdge {
  # The item at the end of the edge
  node: JCRNodeType

  # cursor marks a unique position or index into the connection
  cursor: String!

  # index in the connection
  index: Int
}

# GraphQL representation of a JCR property.
type JCRProperty {
  # The value of the JCR property as a Boolean in case the property is single-valued, null otherwise
  booleanValue: Boolean

  # The values of the JCR property as Booleans in case the property is multiple-valued, null otherwise
  booleanValues: [Boolean]

  # The decrypted value of the JCR encrypted property as a String in case the property is single-valued, null otherwise
  decryptedValue: String

  # The decrypted values of the JCR encrypted property as a Strings in case the property is multiple-valued, null otherwise
  decryptedValues: [String]

  # The value of the JCR property as a Float in case the property is single-valued, null otherwise
  floatValue: Float

  # The values of the JCR property as Floats in case the property is multiple-valued, null otherwise
  floatValues: [Float]

  # The language the property value was obtained in for internationalized properties; null for non-internationalized ones
  language: String

  # The value of the JCR property as a Long in case the property is single-valued, null otherwise
  longValue: Long

  # The values of the JCR property as Longs in case the property is multiple-valued, null otherwise
  longValues: [Long]

  # The name of the JCR property
  name: String!

  # The GraphQL representation of the JCR node the property belongs to.
  node: JCRNode!

  # The value of the JCR property casted as date and returned in this string format: [yyyy-MM-dd'T'HH:mm:ss.SSS] in case the property is single-valued, null otherwise
  notZonedDateValue: String

  # The values of the JCR property casted as date and returned in this string format: [yyyy-MM-dd'T'HH:mm:ss.SSS] in case the property is multiple-valued, null otherwise
  notZonedDateValues: [String]

  # The path of the JCR property
  path: String!

  # GraphQL representation of the node this property references in case the property is single-valued, null otherwise
  refNode: JCRNode

  # GraphQL representations of the nodes this property references in case the property is multiple-valued, null otherwise
  refNodes: [JCRNode]

  # The binary size of the JCR node as a Long, null otherwise
  size: Long

  # The type of the JCR property
  type: JCRPropertyType!

  # The value of the JCR property as a String in case the property is single-valued, null otherwise
  value: String

  # The values of the JCR property as Strings in case the property is multiple-valued, null otherwise
  values: [String]

  # Whether the property is internationalized
  internationalized: Boolean!

  # Returns the property definition that applies to this property.
  definition: JCRPropertyDefinition
}

# A connection to a list of items.
type JCRPropertyConnection {
  # a list of nodes
  nodes: [JCRProperty]

  # a list of edges
  edges: [JCRPropertyEdge]

  # details about this specific page
  pageInfo: PageInfo!
}

# GraphQL representation of a JCR property definition
type JCRPropertyDefinition implements JCRItemDefinition {
  # Property constraints
  constraints: [String]!

  # Gets the node type that contains the declaration of this definition.
  declaringNodeType: JCRNodeType!

  # Gets the displayable name of the property for the given language code. Return the system name in case the label doesn't exists
  displayName(
    # Language
    language: String!
  ): String!

  # Gets the name of the child item.
  name: String!

  # Gets the required type of the property.
  requiredType: JCRPropertyType!

  # Reports whether the item is to be automatically created when its parent node is created.
  autoCreated: Boolean!

  # Reports whether the child item is hidden from UI.
  hidden: Boolean!

  # Reports whether this property has language dependant values.
  internationalized: Boolean!

  # Reports whether the item is mandatory. A mandatory item is one that, if its parent node exists, must also exist.
  mandatory: Boolean!

  # Reports whether this property can have multiple values.
  multiple: Boolean!

  # Reports whether the child item is protected.
  protected: Boolean!
}

# An edge in a connection
type JCRPropertyEdge {
  # The item at the end of the edge
  node: JCRProperty

  # cursor marks a unique position or index into the connection
  cursor: String!

  # index in the connection
  index: Int
}

# Mutations on a JCR property
type JCRPropertyMutation {
  # Add a new value to this property
  addValue(
    language: String
    type: JCRPropertyType
    option: JCRPropertyOption
    value: String
  ): Boolean

  # Add new values to this property
  addValues(
    language: String
    type: JCRPropertyType
    option: JCRPropertyOption
    values: [String]
  ): Boolean

  # Delete this property
  delete(language: String): Boolean

  # Get the path of the property currently being mutated
  path: String

  # Get the graphQL representation of the property currently being mutated
  property: JCRProperty

  # Remove a new value from this property
  removeValue(
    language: String
    type: JCRPropertyType
    option: JCRPropertyOption
    value: String
  ): Boolean

  # Remove values from this property
  removeValues(
    language: String
    type: JCRPropertyType
    option: JCRPropertyOption
    values: [String]
  ): Boolean

  # Set property value
  setValue(
    language: String
    type: JCRPropertyType
    option: JCRPropertyOption
    value: String
  ): Boolean

  # Set property values
  setValues(
    language: String
    type: JCRPropertyType
    option: JCRPropertyOption
    values: [String]
  ): Boolean
}

enum JCRPropertyOption {
  # ENCRYPTED
  ENCRYPTED

  # NOT_ZONED_DATE
  NOT_ZONED_DATE
}

enum JCRPropertyType {
  # BOOLEAN
  BOOLEAN

  # DATE
  DATE

  # DECIMAL
  DECIMAL

  # LONG
  LONG

  # DOUBLE
  DOUBLE

  # BINARY
  BINARY

  # NAME
  NAME

  # PATH
  PATH

  # REFERENCE
  REFERENCE

  # STRING
  STRING

  # UNDEFINED
  UNDEFINED

  # URI
  URI

  # WEAKREFERENCE
  WEAKREFERENCE
}

# JCR Queries
type JCRQuery {
  # Get GraphQL representation of a node by its UUID
  nodeById(
    # The UUID of the node
    uuid: String!

    # Check node validity in this language.
    #
    #  Node validity is determined by multiple conditions:
    #
    #  * The node exists
    #  * The node is not attached to a visibility condition preventing its display
    #  * The node is published in this language
    #  * The node's language has not been invalidated.
    validInLanguage: String
  ): JCRNode

  # Get GraphQL representation of a node by its path
  nodeByPath(
    # The path of the node
    path: String!

    # Check node validity in this language.
    #
    #  Node validity is determined by multiple conditions:
    #
    #  * The node exists
    #  * The node is not attached to a visibility condition preventing its display
    #  * The node is published in this language
    #  * The node's language has not been invalidated.
    validInLanguage: String
  ): JCRNode

  # handles query nodes with QOM factory
  nodesByCriteria(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # The criteria to fetch nodes by
    criteria: InputGqlJcrNodeCriteriaInput!

    # Filter by GraphQL field values
    fieldFilter: InputFieldFiltersInput

    # sort by GraphQL field values
    fieldSorter: InputFieldSorterInput

    # Group fields by criteria
    fieldGrouping: InputFieldGroupingInput
  ): JCRNodeConnection

  # Get GraphQL representations of multiple nodes by their UUIDs
  nodesById(
    # The UUIDs of the nodes
    uuids: [String!]!

    # Check node validity in this language.
    #
    #  Node validity is determined by multiple conditions:
    #
    #  * The node exists
    #  * The node is not attached to a visibility condition preventing its display
    #  * The node is published in this language
    #  * The node's language has not been invalidated.
    validInLanguage: String
  ): [JCRNode]!

  # Get GraphQL representations of multiple nodes by their paths
  nodesByPath(
    # The paths of the nodes
    paths: [String!]!

    # Check node validity in this language.
    #
    #  Node validity is determined by multiple conditions:
    #
    #  * The node exists
    #  * The node is not attached to a visibility condition preventing its display
    #  * The node is published in this language
    #  * The node's language has not been invalidated.
    validInLanguage: String
  ): [JCRNode]!

  # Get GraphQL representations of nodes using a query language supported by JCR
  nodesByQuery(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # The query string
    query: String!

    # The query language
    queryLanguage: QueryLanguage = SQL2

    # Language to use for the query
    language: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by GraphQL field values
    fieldSorter: InputFieldSorterInput

    # Group fields by criteria
    fieldGrouping: InputFieldGroupingInput
  ): JCRNodeConnection

  # Get the workspace of the query
  workspace: Workspace!

  # Execute one or more search queries
  searches(
    # Unique site identifier
    siteKey: String

    # Language to search in
    language: String!

    # Can be LIVE or EDIT
    workspace: Workspace!
  ): GqlSearchQueryExtension
    @deprecated(reason: "This will be removed in future versions")

  # Retrieves the number of active workflow tasks for the current user
  activeWorkflowTaskCountForUser: Int

  # Get a node type by its name
  nodeTypeByName(
    # Node type name
    name: String!
  ): JCRNodeType

  # Get a list of nodetypes based on specified parameter
  nodeTypes(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter on node type
    filter: InputNodeTypesListInput

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): JCRNodeTypeConnection

  # Get multiple node types by their names
  nodeTypesByNames(
    # Node type names
    names: [String]!
  ): [JCRNodeType]
}

# GraphQL representation of a site node
type JCRSite implements JCRNode {
  # Get the last modified date of this node and its descendants. The recursion in descendants can be controlled by recursionTypesFilter. If no filter is passed, recursion will stop by default on sub pages.
  aggregatedLastModifiedDate(
    # The language
    language: String

    # Stop recursion on graphql field values
    recursionTypesFilter: InputNodeTypesInput
  ): String

  # GraphQL representations of the ancestor nodes of the JCR node, top down direction
  ancestors(
    # The path of the topmost ancestor node to include in the result; null or empty string to include all the ancestor nodes
    upToPath: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNode]!

  # GraphQL representations of the child nodes, according to parameters passed
  children(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter of child nodes by their names; null to avoid such filtering
    names: [String]

    # Language to use to get children
    validInLanguage: String

    # Filter of child nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Filter of child nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput

    # Include the current node itself in results
    includesSelf: Boolean = false
  ): JCRNodeConnection

  # Site default language
  defaultLanguage: String

  # GraphQL representation of a descendant node, based on its relative path
  descendant(
    # Name or relative path of the sub node
    relPath: String!
  ): JCRNode

  # GraphQL representations of the descendant nodes, according to parameters passed
  descendants(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter of descendant nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Language to use to get children
    validInLanguage: String

    # Filter of descendant nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput

    # Filter out and stop recursion on nodes by their types; null to avoid such filtering
    recursionTypesFilter: InputNodeTypesInput

    # Filter out and stop recursion on nodes by their property values; null to avoid such filtering
    recursionPropertiesFilter: InputNodePropertiesInput

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput
  ): JCRNodeConnection

  # Site description
  description: String

  # The displayable name of the JCR node
  displayName(
    # Language
    language: String
  ): String

  # Returns the node of the home page
  homePage: JCRNode

  # Retrieves a collection of module IDs, which are installed on the site, the node belongs to
  installedModules: [String]

  # Retrieves a collection of module IDs, which are installed on the site, the node belongs to, as well as dependencies of those modules
  installedModulesWithAllDependencies: [String]

  # Site languages
  languages: [JCRSiteLanguage]

  # Check if the given locales need translation, by comparing last modifications dates with already existing translations
  languagesToTranslate(
    # The translated languages
    languagesTranslated: [String]

    # The languages to check
    languagesToCheck: [String]
  ): [String]

  # The name of the JCR node this object represents
  name: String!

  # GraphQL representation of this node in certain workspace
  nodeInWorkspace(
    # The target workspace
    workspace: Workspace!
  ): JCRNode

  # Get information on the operations that can be done on this node
  operationsSupport: GqlOperationsSupport

  # GraphQL representation of the parent JCR node
  parent: JCRNode

  # The path of the JCR node this object represents
  path: String!

  # GraphQL representations of the properties in the requested language
  properties(
    # The names of the JCR properties; null to obtain all properties
    names: [String]

    # The language to obtain the properties in; must be a valid language code in case any internationalized properties are requested, does not matter for non-internationalized ones
    language: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRProperty]!

  # The GraphQL representation of the property in the requested language; null if the property does not exist
  property(
    # The name of the JCR property
    name: String!

    # The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
    language: String
  ): JCRProperty

  # GraphQL representations of the reference properties that target the current JCR Node
  references(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): JCRPropertyConnection!

  # Site server name
  serverName: String

  # Site key
  sitekey: String

  # The UUID of the JCR node this object represents
  uuid: String!

  # Get the workspace of the query
  workspace: Workspace!

  # Check if the current user has a specific permission
  hasPermission(
    # The name of the permission
    permissionName: String!
  ): Boolean

  # Read default Work in progress information. Set by "wip.checkbox.checked" system proprety
  defaultWipInfo: wipInfo

  # Read work in progress information for a given node
  wipInfo: wipInfo

  # Get vanity URLs from the current node filtered by the parameters
  vanityUrls(
    # Languages
    languages: [String]

    # Filter results based on graphql field values
    fieldFilter: InputFieldFiltersInput
  ): [VanityUrl]

  # Retrieve lock info of the current node
  lockInfo: LockInfo

  # Aggregated publication info about the JCR node
  aggregatedPublicationInfo(
    # Publication language
    language: String!

    # Whether to take sub-nodes into account when calculating the aggregated publication status
    subNodes: Boolean = false

    # Whether to take references into account when calculating the aggregated publication status
    references: Boolean = false
  ): GqlPublicationInfo!

  # Give access to the experience fields for the current node
  asExperience: GqlExperience
  jExperience(
    # Unomi profile id
    profileId: String

    # Unomi session id
    sessionId: String
  ): PersonalizedResult

  # Render URL in ajax mode
  ajaxRenderUrl: String

  # Returns the first parent of the current node that can be displayed in full page. If no matching node is found, null is returned.
  displayableNode: JCRNode

  # Gets the fully rendered content for this node
  renderedContent(
    # Name of the view
    view: String

    # Template type
    templateType: String

    # Rendering context configuration
    contextConfiguration: String

    # Language
    language: String

    # Main resource path
    mainResourcePath: String

    # Is edit mode
    isEditMode: Boolean

    # Additional request attributes
    requestAttributes: [InputRenderRequestAttributeInput]
  ): RenderedNode

  # Check if the node as a renderable template associated with it (not a view a template).
  isDisplayableNode: Boolean

  # GraphQL representation of the site the JCR node belongs to, or the system site in case the node does not belong to any site
  site: JCRSite

  # Returns the next available name for a node, appending if needed numbers.
  findAvailableNodeName(nodeType: String, language: String): String

  # Returns edit lock status of the current node object
  lockedAndCannotBeEdited: Boolean

  # Returns a list of types allowed under the provided node
  allowedChildNodeTypes(
    # Whether all sub-types of allowed child node types should be included
    includeSubTypes: Boolean = true

    # Filter by GraphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeType]

  # Returns the node definition that applies to this node.
  definition: JCRNodeDefinition

  # Returns an array of <code>NodeType</code> objects representing the mixin node types in effect for this node.
  mixinTypes(
    # Filter by GraphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeType]!

  # Get the primary node type of this node
  primaryNodeType: JCRNodeType!

  # Reports if the current node matches the nodetype(s) passed in parameter
  isNodeType(
    # Node type name
    type: InputNodeTypesInput!
  ): Boolean!
}

# Site language representation
type JCRSiteLanguage {
  # Display name
  displayName(
    # Language
    language: String
  ): String

  # Language code
  language: String

  # Is this language active in edit
  activeInEdit: Boolean

  # Is this language active in live
  activeInLive: Boolean

  # Is this language mandatory
  mandatory: Boolean
}

# GraphQL representation of a Tag
type JCRTag {
  # The name of the tag
  name: String!

  # Get the occurences of a tag
  occurences: Long!
}

# JCR Queries
type JCRTags {
  # Handles suggestion tags queries
  suggest(
    # The prefix of the tags
    prefix: String!

    # Max number of tags to get
    limit: Long!

    # The root node to start the search
    startPath: String!

    # Minimal occurrences to return a tag
    minCount: Long

    # Offset value
    offset: Long

    # Sort the tags by occurrences
    sortByCount: Boolean
  ): [JCRTag]
}

type JWTToken {
  claims: String
  id: String
  token: String
}

# Admin mutations
type JahiaAdminMutation {
  # Mutate an OSGi configuration
  configuration(
    # Configuration pid ot factory pid
    pid: String!

    # If factory pid, configiration identifier (filename suffix)
    identifier: String
  ): GqlConfigurationMutation

  # Create a task
  createTask(
    # Service name
    service: String!

    # Task name
    name: String!
  ): Boolean

  # Delete a task
  deleteTask(
    # Service name
    service: String!

    # Task name
    name: String!
  ): Boolean

  # Shutdown the server
  shutdown(
    # In seconds, maximum time to wait for server to be ready to shutdown
    timeout: Int

    # Force immediate shutdown even if server is busy
    force: Boolean

    # Do not send the shutdown event
    dryRun: Boolean
  ): Boolean

  # Distributed sessions admin
  distributedSessions: GqlDistributedSessionsMutation
}

# Jahia admin queries root
type JahiaAdminQuery {
  # Read an OSGi configuration
  configuration(
    # Configuration pid ot factory pid
    pid: String!

    # If factory pid, configiration identifier (filename suffix)
    identifier: String
  ): GqlConfigurationQuery

  # Version of the running Jahia instance
  version: JahiaVersion

  # Distributed sessions admin
  distributedSessions: GqlDistributedSessionsQuery

  # HealthCheck node
  healthCheck(severity: GqlProbeSeverity): GqlHealthCheck

  # Lists tasks running on the Jahia server. A server should not be stopped/restarted when any of these tasks are present. These tasks are specific to the server being queried and are not shared accorss a cluster
  tasks: [task]

  # Get server load
  load: Load
}

# Version of the running Jahia instance
type JahiaVersion {
  # Build number of the running Jahia instance
  build: String

  # Build date of the running Jahia instance
  buildDate: String

  # Release of the running Jahia instance
  release: String

  # Flag returning if running Jahia instance is a SNAPSHOT
  isSnapshot: Boolean
}

# Server load
type Load {
  # Get requests load
  requests: LoadValue

  # Get JCR Sessions load
  sessions: LoadValue
}

enum LoadInterval {
  # ONE
  ONE

  # FIVE
  FIVE

  # FIFTEEN
  FIFTEEN
}

# Load value
type LoadValue {
  # Exponential moving average
  average(interval: LoadInterval): Float

  # Instantaneous count
  count: Int
}

# Information on node lock
type LockInfo {
  # Can the node be locked
  canLock: Boolean

  # Can the node be unlocked
  canUnlock: Boolean

  # Is node lockable
  details(
    # language in which to retrieve details
    language: String
  ): [GqlLockDetail]

  # Is node lockable
  lockable: Boolean
}

# Long type
scalar Long

# Metadata properties for all content
type Metadata {
  # Date of creation for the associated content
  created: Date

  # Original author of the associated content
  createdBy: String

  # Date of last modification of the associated content
  lastModified: Date

  # Author of last modification of the associated content
  lastModifiedBy: String

  # Date of last publication of the associated content
  lastPublished: Date

  # Author of last publication of the associated content
  lastPublishedBy: String
}

enum MulticriteriaEvaluation {
  # The result criteria evaluates positive if all sub-criteria evaluate positive
  ALL

  # The result criteria evaluates positive if any sub-criteria evaluates positive
  ANY

  # The result criteria evaluates positive if no sub-criteria evaluates positive
  NONE
}

# Root mutation type
type Mutation {
  # Admin Mutation
  admin: AdminMutation!

  # jExperience Mutations
  jExperience: GqljExperienceMutation!

  # JCR Mutation
  jcr(
    # The name of the workspace to fetch the node from; either 'edit', 'live', or null to use 'edit' by default
    workspace: Workspace

    # Should save
    save: Boolean = true
  ): JCRMutation

  # Generate a new JWT token
  jwtToken(scopes: [String]!, referer: [String], ips: [String]): JWTToken

  # Main access field to the DX GraphQL Form mutation API
  forms: GqlEditorFormMutations
  mutateWorkflows(definition: String): [WorkflowMutation]
}

enum NodeNamingConflictResolutionStrategy {
  # FAIL
  FAIL

  # RENAME
  RENAME
}

# GraphQL representation of node type tree entry
type NodeTypeTreeEntry {
  # Return the children if any
  children: [NodeTypeTreeEntry]

  # Return icon URL with png extension
  iconURL(
    # if true (default) add '.png' to the icon path.
    addExtension: Boolean = true
  ): String

  # Return uniq identifier for tree entry
  id: String

  # Return the i18n label
  label: String

  # Return nodeType name
  name: String

  # Return nodeType
  nodeType: JCRNodeType

  # Return the parent tree entry (if any)
  parent: NodeTypeTreeEntry
}

# Number Range Input Object
type NumberRange {
  # Greater than a number
  gt: Float

  # Greate than or equal to a number
  gte: Float

  # Less than a number
  lt: Float

  # Less than or equal to a number
  lte: Float

  # Name to describe the facet
  name: String!
}

type NumberRangeValue {
  count: Int
  range: NumberRange
}

enum Operation {
  # AND
  AND

  # OR
  OR
}

# Direction of sort
enum OrderDirection {
  # Ascendant order
  ASC

  # Descendant order
  DESC
}

enum OrderType {
  # Ascendant order
  ASC

  # Descendant order
  DESC
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, the cursor to continue.
  nodesCount: Int

  # When paginating forwards, the cursor to continue.
  totalCount: Int
}

enum PasteMode {
  # COPY
  COPY

  # MOVE
  MOVE
}

enum PathType {
  # The specified path is an ancestor, so all its descendants will be considered in the query
  ANCESTOR

  # The specified path is a parent, so all its direct children will be considered in the query
  PARENT

  # The specified path is a node itself, so only this node will be considered in the query
  OWN
}

# Token details
type PersonalApiToken {
  # Creation date and time
  createdAt: String

  # Expiration date
  expireAt: String

  # The key of the token, used for looking it up
  key: String

  # The name of the token
  name: String

  # Token state
  state: TokenState

  # Last modification date and time
  updatedAt: String

  # The user associated to the token
  user: User
}

# A connection to a list of items.
type PersonalApiTokenConnection {
  # a list of nodes
  nodes: [PersonalApiToken]

  # a list of edges
  edges: [PersonalApiTokenEdge]

  # details about this specific page
  pageInfo: PageInfo!
}

# An edge in a connection
type PersonalApiTokenEdge {
  # The item at the end of the edge
  node: PersonalApiToken

  # cursor marks a unique position or index into the connection
  cursor: String!

  # index in the connection
  index: Int
}

# Mutations for Personal Api Tokens
type PersonalApiTokensMutation {
  # Create a new token
  createToken(
    # Name to give to the token
    name: String!

    # The site the user belongs to, null if global user
    site: String

    # Expiration date of the token
    expireAt: String

    # Scopes attached to this token
    scopes: [String]

    # State to give the newly created token
    state: TokenState
  ): String

  # Delete an existing token
  deleteToken(
    # The token key
    key: String!
  ): Boolean

  # Update an existing token
  updateToken(
    # The token key
    key: String!

    # Name to give to the token
    name: String

    # Expiration date of the token, use empty string to unset expiration date
    expireAt: String

    # Scopes attached to this token
    scopes: [String]

    # State to give the token
    state: TokenState
  ): Boolean
}

# Queries for Personal Api Tokens
type PersonalApiTokensQuery {
  # Get available scopes
  availableScopes: [GqlScope]

  # Get token details, based on key
  tokenByKey(
    # The token key
    key: String!
  ): PersonalApiToken

  # Get token details, based on user and token name
  tokenByUserAndName(
    # The user id
    userId: String!

    # The site the user belongs to, null if global user
    site: String

    # The token name
    tokenName: String!
  ): PersonalApiToken

  # List tokens attached to the provided user ID and site key
  tokens(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # If a userId is provided, only returns tokens assigned to that user.
    userId: String

    # The site the user belongs to, null if global user
    site: String

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput
  ): PersonalApiTokenConnection

  # Check if the token is valid for authentication
  verifyToken(
    # The token
    token: String!
  ): Boolean
}

type PersonalizedResult {
  optimizationTestVariant: JCRNode
  personalizedVariant: JCRNode
  personalizedVariants: [JCRNode]
  profileId: String
  sessionId: String
}

# GraphQL representation of a principal
interface Principal {
  # Full display name
  displayName: String

  # List of groups this principal belongs to
  groupMembership(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Return only groups which belong to this site
    site: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput
  ): GroupConnection!

  # Name
  name: String!

  # Get the corresponding JCR node
  node: JCRNode

  # Site where the principal is defined
  site: JCRSite

  # Is this principal member of the specified group
  memberOf(
    # Target group
    group: String

    # Site where the group is defined
    site: String
  ): Boolean
}

# A connection to a list of items.
type PrincipalConnection {
  # a list of nodes
  nodes: [Principal]

  # a list of edges
  edges: [PrincipalEdge]

  # details about this specific page
  pageInfo: PageInfo!
}

# An edge in a connection
type PrincipalEdge {
  # The item at the end of the edge
  node: Principal

  # cursor marks a unique position or index into the connection
  cursor: String!

  # index in the connection
  index: Int
}

enum PropertyEvaluation {
  # The property is present
  PRESENT

  # The property is absent
  ABSENT

  # The property value is equal to given one
  EQUAL

  # The property value is different from given one
  DIFFERENT
}

enum PublicationStatus {
  # PUBLISHED
  PUBLISHED

  # MODIFIED
  MODIFIED

  # NOT_PUBLISHED
  NOT_PUBLISHED

  # UNPUBLISHED
  UNPUBLISHED

  # MANDATORY_LANGUAGE_UNPUBLISHABLE
  MANDATORY_LANGUAGE_UNPUBLISHABLE

  # LIVE_MODIFIED
  LIVE_MODIFIED

  # LIVE_ONLY
  LIVE_ONLY

  # CONFLICT
  CONFLICT

  # MANDATORY_LANGUAGE_VALID
  MANDATORY_LANGUAGE_VALID

  # DELETED
  DELETED

  # MARKED_FOR_DELETION
  MARKED_FOR_DELETION
}

# Root query type
type Query {
  # Search in Jahia using Augmented Search
  search(
    # Search query
    q: String!

    # List of unique site identifiers. Search across all sites if not provided
    siteKeys: [String]

    # Language to search in
    language: String = "en"

    # Can be LIVE or EDIT
    workspace: Workspace = LIVE

    # Where to search, can be CONTENT or FILES
    searchIn: [SearchIn]

    # Filtering specification
    filters: Inputfilter

    # Boost specification
    boosts: Inputboost

    # Function score id
    functionScoreId: String
  ): augmentedSearchResult

  # Get the current user
  currentUser: Current_32_user
  jExperience: GqljExperience

  # JCR Queries
  jcr(
    # The name of the workspace to fetch the node from; either EDIT, LIVE, or null to use EDIT by default
    workspace: Workspace
  ): JCRQuery!

  # Main access field to the DX GraphQL Form API
  forms: GqlEditorForms

  # Tag Queries
  tag: JCRTags

  # Admin Queries
  admin: AdminQuery!

  # Main access field to the DX GraphQL Dashboard API
  dashboard: GqlDashboard

  # default finder for categoryById
  categoryById(
    # Return content from live or default workspace
    preview: Boolean = false

    # Content language, defaults to English
    language: String = "en"
    id: String
  ): Category

  # default finder for categoryByPath
  categoryByPath(
    # Return content from live or default workspace
    preview: Boolean = false

    # Content language, defaults to English
    language: String = "en"
    path: String
  ): Category
}

enum QueryFunction {
  # Query function for lower case comparison
  LOWER_CASE

  # Query function for upper case comparison
  UPPER_CASE

  # Query function for node name comparison
  NODE_NAME

  # Query function for node local name comparison
  NODE_LOCAL_NAME
}

# JCR query languages available to use for nodes querying
enum QueryLanguage {
  # SQL2 query language
  SQL2

  # XPath query language
  XPATH
}

# Number Range Input Object
type Range {
  # From value [used in Range facet]
  from: String

  # Name to describe the facet
  name: String!

  # To value [used in Range facet]
  to: String
}

# Rendering result for a node
type RenderedNode {
  # Contraints on this node
  constraints: String

  # Rendering output
  output: String

  # List of static assets
  staticAssets(
    # Assets type
    type: String!
  ): [StaticAsset]
}

# The target position of reordered child nodes
enum ReorderedChildrenPosition {
  # Specified children are sorted in a requested order and placed at the end of the list after the remaining children
  LAST

  # Specified children are sorted in a requested order, but remaining are kept at their places
  INPLACE

  # Specified children are sorted in a requested order and placed at the top, before all remaining children
  FIRST
}

# Index in which search should be performed
enum SearchIn {
  # files index
  FILES

  # content index
  CONTENT
}

# Order of sort
enum SortOrder {
  # Ascendant order
  ASC

  # Descendant order
  DESC
}

enum SortType {
  # Ascendant order
  ASC

  # Descendant order
  DESC
}

# Simple numeric aggregation on properties values
type StatAggregation {
  # The date representation of a JCR node property
  datePropertyValue(
    # The name of the JCR property
    name: String!

    # The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
    language: String
  ): String

  # The float representation of a JCR node property
  floatPropertyValue(
    # The name of the JCR property
    name: String!

    # The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
    language: String
  ): Float

  # The long representation of a JCR node property
  longPropertyValue(
    # The name of the JCR property
    name: String!

    # The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
    language: String
  ): Long
}

# Representation of a static assert
type StaticAsset {
  # Asset key
  key: String

  # Asset option
  option(
    # Asset option name
    name: String!
  ): String
}

# Root subscription type
type Subscription {
  # Lock the node for edition and subscribe to hold the lock. The node is automatically unlocked when the client disconnect or close the connection
  subscribeToEditorLock(
    # Uuid of the node to be locked.
    nodeId: String!

    # An ID generated client side used to identify the lock
    editorID: String!
  ): String

  # Subscription on background jobs
  backgroundJobSubscription(
    # The target scheduler for listening jobs
    targetScheduler: TargetScheduler = BOTH

    # Subscribe only to job with matching group names
    filterByGroups: [String]

    # Subscribe only to job with matching names
    filterByNames: [String]

    # Subscribe only to job with matching job statuses
    filterByJobStatuses: [GqlBackgroundJobStatus]

    # Subscribe only to job with matching job states
    filterByJobStates: [GqlBackgroundJobState]
  ): GqlBackgroundJob
}

enum Target {
  # PAGE
  PAGE

  # CONTENT
  CONTENT

  # CUSTOM
  CUSTOM
}

# The target scheduler(s)
enum TargetScheduler {
  # Persisted scheduler will be used
  SCHEDULER

  # RAM scheduler will be used
  RAM_SCHEDULER

  # Both persisted and RAM schedulers will be used
  BOTH
}

type TermValue {
  count: Int

  # Value of term
  value: String
}

enum TokenState {
  # ACTIVE
  ACTIVE

  # DISABLED
  DISABLED
}

enum Type {
  # OPTIMIZATION
  OPTIMIZATION

  # PERSONALIZATION
  PERSONALIZATION
}

# GraphQL representation of a Jahia user
type User implements Principal {
  # Full display name
  displayName: String

  # Email of the user
  email: String

  # First name of the user
  firstname: String

  # List of groups this principal belongs to
  groupMembership(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Return only groups which belong to this site
    site: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput
  ): GroupConnection!

  # Preferred language by the user
  language: String

  # Last name of the user
  lastname: String

  # Displays if user is locked
  locked: Boolean

  # User name
  name: String! @deprecated(reason: "Deprecated")

  # Get the corresponding JCR node
  node: JCRNode

  # User organization
  organization: String

  # User property
  property(
    # The name of the property
    name: String!
  ): String

  # Site where the user is defined
  site: JCRSite

  # Username of the user
  username: String!

  # Is this principal member of the specified group
  memberOf(
    # Target group
    group: String

    # Site where the group is defined
    site: String
  ): Boolean
}

# User admin queries
type UserAdminQuery {
  # Get a user
  user(
    # User name
    username: String!

    # Site where the user is defined
    site: String
  ): User

  # Get users list
  users(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput
  ): UserConnection
}

# A connection to a list of items.
type UserConnection {
  # a list of nodes
  nodes: [User]

  # a list of edges
  edges: [UserEdge]

  # details about this specific page
  pageInfo: PageInfo!
}

# An edge in a connection
type UserEdge {
  # The item at the end of the edge
  node: User

  # cursor marks a unique position or index into the connection
  cursor: String!

  # index in the connection
  index: Int
}

# User group queries
type UserGroupQuery {
  # Get a group
  group(
    # Group name
    groupName: String!

    # Site where the group is defined
    site: String
  ): Group
}

# GraphQL representation of a vanity URL
type VanityUrl implements JCRNode {
  # Get the last modified date of this node and its descendants. The recursion in descendants can be controlled by recursionTypesFilter. If no filter is passed, recursion will stop by default on sub pages.
  aggregatedLastModifiedDate(
    # The language
    language: String

    # Stop recursion on graphql field values
    recursionTypesFilter: InputNodeTypesInput
  ): String

  # GraphQL representations of the ancestor nodes of the JCR node, top down direction
  ancestors(
    # The path of the topmost ancestor node to include in the result; null or empty string to include all the ancestor nodes
    upToPath: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNode]!

  # GraphQL representations of the child nodes, according to parameters passed
  children(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter of child nodes by their names; null to avoid such filtering
    names: [String]

    # Language to use to get children
    validInLanguage: String

    # Filter of child nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Filter of child nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput

    # Include the current node itself in results
    includesSelf: Boolean = false
  ): JCRNodeConnection

  # GraphQL representation of a descendant node, based on its relative path
  descendant(
    # Name or relative path of the sub node
    relPath: String!
  ): JCRNode

  # GraphQL representations of the descendant nodes, according to parameters passed
  descendants(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter of descendant nodes by their types; null to avoid such filtering
    typesFilter: InputNodeTypesInput

    # Language to use to get children
    validInLanguage: String

    # Filter of descendant nodes by their property values; null to avoid such filtering
    propertiesFilter: InputNodePropertiesInput

    # Filter out and stop recursion on nodes by their types; null to avoid such filtering
    recursionTypesFilter: InputNodeTypesInput

    # Filter out and stop recursion on nodes by their property values; null to avoid such filtering
    recursionPropertiesFilter: InputNodePropertiesInput

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput

    # Sort by graphQL fields values
    fieldSorter: InputFieldSorterInput

    # Group fields according to specified criteria
    fieldGrouping: InputFieldGroupingInput
  ): JCRNodeConnection

  # The displayable name of the JCR node
  displayName(
    # Language
    language: String
  ): String

  # The language of the content object to which the vanity URL maps to
  language: String

  # Check if the given locales need translation, by comparing last modifications dates with already existing translations
  languagesToTranslate(
    # The translated languages
    languagesTranslated: [String]

    # The languages to check
    languagesToCheck: [String]
  ): [String]

  # The name of the JCR node this object represents
  name: String!

  # GraphQL representation of this node in certain workspace
  nodeInWorkspace(
    # The target workspace
    workspace: Workspace!
  ): JCRNode

  # Get information on the operations that can be done on this node
  operationsSupport: GqlOperationsSupport

  # GraphQL representation of the parent JCR node
  parent: JCRNode

  # The path of the JCR node this object represents
  path: String!

  # GraphQL representations of the properties in the requested language
  properties(
    # The names of the JCR properties; null to obtain all properties
    names: [String]

    # The language to obtain the properties in; must be a valid language code in case any internationalized properties are requested, does not matter for non-internationalized ones
    language: String

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRProperty]!

  # The GraphQL representation of the property in the requested language; null if the property does not exist
  property(
    # The name of the JCR property
    name: String!

    # The language to obtain the property in; must be a valid language code for internationalized properties, does not matter for non-internationalized ones
    language: String
  ): JCRProperty

  # GraphQL representations of the reference properties that target the current JCR Node
  references(
    # fetching only nodes before this node (exclusive)
    before: String

    # fetching only nodes after this node (exclusive)
    after: String

    # fetching only the first certain number of nodes
    first: Int

    # fetching only the last certain number of nodes
    last: Int

    # fetching only nodes after this node (inclusive)
    offset: Int

    # fetching only the first certain number of nodes
    limit: Int

    # Filter by graphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): JCRPropertyConnection!

  # The node targeted by this vanity URL
  targetNode: JCRNode

  # The vanity URL
  url: String

  # The UUID of the JCR node this object represents
  uuid: String!

  # Get the workspace of the query
  workspace: Workspace!

  # Check if the current user has a specific permission
  hasPermission(
    # The name of the permission
    permissionName: String!
  ): Boolean

  # true if the URL mapping is activated or false if it is not activated
  active: Boolean

  # true whether this URL mapping is the default one for the language
  default: Boolean

  # Read default Work in progress information. Set by "wip.checkbox.checked" system proprety
  defaultWipInfo: wipInfo

  # Read work in progress information for a given node
  wipInfo: wipInfo

  # Get vanity URLs from the current node filtered by the parameters
  vanityUrls(
    # Languages
    languages: [String]

    # Filter results based on graphql field values
    fieldFilter: InputFieldFiltersInput
  ): [VanityUrl]

  # Retrieve lock info of the current node
  lockInfo: LockInfo

  # Aggregated publication info about the JCR node
  aggregatedPublicationInfo(
    # Publication language
    language: String!

    # Whether to take sub-nodes into account when calculating the aggregated publication status
    subNodes: Boolean = false

    # Whether to take references into account when calculating the aggregated publication status
    references: Boolean = false
  ): GqlPublicationInfo!

  # Give access to the experience fields for the current node
  asExperience: GqlExperience
  jExperience(
    # Unomi profile id
    profileId: String

    # Unomi session id
    sessionId: String
  ): PersonalizedResult

  # Render URL in ajax mode
  ajaxRenderUrl: String

  # Returns the first parent of the current node that can be displayed in full page. If no matching node is found, null is returned.
  displayableNode: JCRNode

  # Gets the fully rendered content for this node
  renderedContent(
    # Name of the view
    view: String

    # Template type
    templateType: String

    # Rendering context configuration
    contextConfiguration: String

    # Language
    language: String

    # Main resource path
    mainResourcePath: String

    # Is edit mode
    isEditMode: Boolean

    # Additional request attributes
    requestAttributes: [InputRenderRequestAttributeInput]
  ): RenderedNode

  # Check if the node as a renderable template associated with it (not a view a template).
  isDisplayableNode: Boolean

  # GraphQL representation of the site the JCR node belongs to, or the system site in case the node does not belong to any site
  site: JCRSite

  # Returns the next available name for a node, appending if needed numbers.
  findAvailableNodeName(nodeType: String, language: String): String

  # Returns edit lock status of the current node object
  lockedAndCannotBeEdited: Boolean

  # Returns a list of types allowed under the provided node
  allowedChildNodeTypes(
    # Whether all sub-types of allowed child node types should be included
    includeSubTypes: Boolean = true

    # Filter by GraphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeType]

  # Returns the node definition that applies to this node.
  definition: JCRNodeDefinition

  # Returns an array of <code>NodeType</code> objects representing the mixin node types in effect for this node.
  mixinTypes(
    # Filter by GraphQL fields values
    fieldFilter: InputFieldFiltersInput
  ): [JCRNodeType]!

  # Get the primary node type of this node
  primaryNodeType: JCRNodeType!

  # Reports if the current node matches the nodetype(s) passed in parameter
  isNodeType(
    # Node type name
    type: InputNodeTypesInput!
  ): Boolean!
}

type VanityUrlMappingMutation {
  # Deletes the current vanity url
  delete: Boolean

  # Get mutation on underlying node
  nodeMutation: JCRNodeMutation

  # Get the identifier of the node currently being mutated
  uuid: String

  # Move the vanity URL to another node
  move(
    # The path of the target node
    target: String!
  ): Boolean

  # Update vanity URL
  update(
    # Desired value of the active flag or null to keep existing value
    active: Boolean

    # Desired value of the default flag or null to keep existing value
    defaultMapping: Boolean

    # Desired vanity URL language or null to keep existing value
    language: String

    # Desired URL value or null to keep existing value
    url: String
  ): Boolean
}

enum WipStatus {
  # Work in progress disabled
  DISABLED

  # Work in progress for all languages
  ALL_CONTENT

  # Work in progress for specified languages
  LANGUAGES
}

type Workflow {
  startUser: String
}

type WorkflowMutation {
  abortWorkflow: Boolean
  workflow: Workflow
}

# JCR workspace to use for the operations
enum Workspace {
  # Edit workspace
  EDIT

  # Live workspace
  LIVE
}

type ZipFileMutation {
  # zip a file
  addToZip(
    # list of paths or ids to zip
    pathsOrIds: [String]!
  ): Boolean

  # unzip a zip file
  unzip(
    # destination path to unzip
    path: String!
  ): Boolean
}

# Generic object with search results which contains facets and results
type augmentedSearchResult {
  # Provides access to min and max values for a specific field across the selected dataset
  numberRange(
    # Defines the field to operate on, this field is required.
    field: String!
  ): GqlMetricsFacetResult

  # Retrieves aggregations for range facet
  rangeFacet(
    # Defines the field to aggregate on, this field is required.
    field: String!

    # List of available ranges to be used
    ranges: [InputRange]
  ): GqlRangeFacetResult

  # Retrieves nodes matching a search
  results(
    # Page count to offset the results window
    page: Int

    # Number of documents in the results window
    size: Int = 25

    # Sort object, by default, doesnt do any sorting and return the results by weight.
    sortBy: [InputsortV2]
  ): searchResultsV2

  # Retrieves aggregations for term facet
  termFacet(
    # Defines the field to aggregate on, this field is required.
    field: String!

    # Maximum number of facet groups returned.
    max: Int = 10

    # Minimum number of documents for a value to return as a facet.
    minDocCount: Int = 1

    # Label to be used for missing values on this field. If not specified, missing fields will not be counted
    missingValue: String

    # Defines whether the facet aggregation should be executed on the exact search filter (disjunctive: false) or on a modified version of the filter without the current facet field.
    disjunctive: Boolean = false
  ): GqlTermFacetResult

  # Retrieves aggregations for tree facet
  treeFacet(
    # Defines the field to aggregate on, this field is required.
    field: String!

    # The root path to fetch children from
    rootPath: String!

    # Maximum number of facet groups returned.
    max: Int = 10

    # Minimum number of documents for a value to return as a facet.
    minDocCount: Int = 1

    # Label to be used for missing values on this field. If not specified, missing fields will not be counted
    missingValue: String

    # Defines whether the facet aggregation should be executed on the exact search filter (disjunctive: false) or on a modified version of the filter without the current facet field.
    disjunctive: Boolean = false
  ): GqlTreeFacetResult
}

# Information related to specific indexing job
type indexJob {
  # The ID of the job that was just started
  id: String

  # Relation to a Jahia project object
  project: project

  # Indexing job status
  status: jobStatus
}

# Information about indexing jobs
type indexMutationResult {
  # Information about indexing jobs, one per site indexed
  jobs: [indexJob]
}

# Status of indexation
enum indexationStatus {
  # Indexation has been scheduled
  SCHEDULED

  # Indexation has started
  STARTED

  # Indexation has completed
  COMPLETED
}

# Representation of indexed site
type indexedSite {
  # End time of most recent indexation as ISO string
  indexationEnd: String

  # Scheduled time of most recent indexation as ISO string
  indexationScheduled: String

  # Start time of most recent indexation as ISO string
  indexationStart: String

  # Status of indexation
  indexationStatus: indexationStatus

  # Site key
  siteKey: String
}

# Status of job
enum jobStatus {
  # Job has started
  STARTED

  # Job has completed
  COMPLETED
}

# Site specific information
type project {
  # Unique site identifier
  siteKey: String
}

# Search facet
type searchFacet {
  # Data based on facets specified in the search
  data: [GqlSearchFacetValue]

  # JCR name of the field to filter by
  field: String

  # Type of the facet
  type: String
}

# Detailed information about search hit
type searchHit {
  # Date when node was created
  created: String

  # User who created the node
  createdBy: String

  # Prettified displayable name of the node
  displayableName: String

  # Short extract from the hit
  excerpt: String

  # ID of the node
  id: String

  # Keywords associated with this hit
  keywords: [String]

  # Date and time of last modification
  lastModified: String

  # User who modified the node last
  lastModifiedBy: String

  # Date and time of last publication
  lastPublished: String

  # User who published the node last
  lastPublishedBy: String

  # Formatted link to the node
  link: String

  # Mime type of the node
  mimeType: String

  # Information about JCR node, lookup JCRNode in API docs for deeper insight
  node: JCRNode

  # Main type of the node, e.g jnt:page
  nodeType: String

  # Path of the node
  path: String

  # Determines how relevant a match is to the query
  score: Float

  # Tags associated with this hit
  tags: [String]
}

# Detailed information about search hit
type searchHitV2 {
  # Date when node was created
  created: String

  # User who created the node
  createdBy: String

  # Prettified displayable name of the node
  displayableName: String

  # Short extract from the hit
  excerpt: String

  # ID of the node
  id: String

  # Keywords associated with this hit
  keywords: [String]

  # Date and time of last modification
  lastModified: String

  # User who modified the node last
  lastModifiedBy: String

  # Date and time of last publication
  lastPublished: String

  # User who published the node last
  lastPublishedBy: String

  # Formatted link to the node
  link: String

  # Mime type of the node
  mimeType: String

  # Main type of the node, e.g jnt:page
  nodeType: String

  # Path of the node
  path: String

  # Fetch the value of the requested property, property name can be pass as an alias or as an argument
  property(
    # Name of the property to return
    name: String
  ): String

  # Determines how relevant a match is to the query
  score: Float

  # Tags associated with this hit
  tags: [String]
}

# Object with search results
type searchResults {
  # Array of facets to narrow down the search
  facets: [searchFacet]

  # This flag indicates that more data is available by using different filters
  hasMore: Boolean

  # Array of hits based on the search query
  hits: [searchHit]

  # Number of hits on page
  hitsOnPage: Long

  # Time taken by query
  took: String

  # Total number of hits
  totalHits: Long
}

# Object with search results
type searchResultsV2 {
  # This flag indicates that more data is available by using different filters
  hasMore: Boolean

  # Array of hits based on the search query
  hits: [searchHitV2]

  # Number of hits on page
  hitsOnPage: Long

  # Time taken by query
  took: String

  # Total number of hits
  totalHits: Long
}

# List of indexed sites
type siteList {
  # Database connection id
  connectionId: String

  # Indexed sites
  sites: [indexedSite]

  # Total number of indexed sites
  totalCount: Int
}

# Task that prevents server from shutdown
type task {
  # The name of the task associated with the service
  name: String

  # Service attached to the task being monitored
  service: String

  # Datetime at which the task was started or registered
  started: String
}

# Work in progress information
type wipInfo {
  # The languages set for Work in progress
  languages: [String]

  # Get WIP status
  status: WipStatus
}
